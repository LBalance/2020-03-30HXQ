<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="17.12">
<procedure name="main">
<interface/>
<body>
<c></c>
<l>BaoluoDiameterUp:=28.03		//包络线直径上限</l>
<l>BaoluoDiameterDown:=27.54	//包络线直径下限</l>
<l>GouWidthUp:=1.205			   //钩宽上限</l>
<l>GouWidthDown:=1.0 		   //钩宽下限</l>
<l>input_Scale_1:=0.996   //顶部直径比值mm/pix///②//对求的值的缩放比例</l>
<l>input_Scale_2 :=60     //钩套内孔钩宽度</l>
<l>input_Scale_3 :=0.6    //钩与钩套交集区的最大內圆半径</l>
<l>input_Scale_4 :=12     //钩顶半径差值阀，等于0只时出良品</l>
<c>*27.85/2373=0.011736</c>
<c></c>
<l>prav2_1:=0 </l>
<l>prav2_2:=0</l>
<l>prav2_3:=0</l>
<l>prav2_4:=0</l>
<l>prav2_5:=2100               //料崩面积阈值</l>
<l>prav2_6:=2</l>
<l>prav2_7:=0</l>
<l>prav2_8:=0</l>
<c></c>
<l>CaoWidthUp:=0.68      //槽宽上限</l>
<l>CaoWidthDown:=0.40      //槽宽下限</l>
<l>YiWuArea:=1000       //异物面积</l>
<l>YiWuHeight:=30      //异物高度</l>
<l>input_Scale_1s :=20    //钩中心到上下槽距离差值（像素）</l>
<l>input_Scale_2s :=20000     //片上黑色区域面积判断阀值</l>
<l>input_Scale_3s :=1     //备用</l>
<l>input_Scale_4s :=1     //备用</l>
<c>*d=23.43*3.1416/7500=0.009814</c>
<c></c>
<l>WindowHandle :=200000</l>
<c>    *'C:/Users/Administrator/MVS/Data'</c>
<c>    *'D:/Images/Top/Bad' </c>
<c>    *'D:/Images/Top/All'</c>
<c>    </c>
<l>OKNUM:=0</l>
<c></c>
<l>workPostion:= 0</l>
<c></c>
<l>if(workPostion==0)//第一工位前3张图片处理</l>
<l>    list_image_files(\
    'D:/Images/Top/Bad'       ,\
                     'default', [], ImageFiles)</l>
<c>    </c>
<l>    tuple_length (ImageFiles, Length)</l>
<c>    </c>
<l>    for Index := 0 to Length-1 by 1</l>
<l>        *input_Scale_2 :=0.3</l>
<l>        read_image(Image, ImageFiles[Index])</l>
<c>    </c>
<c>        *检测槽内异物，包络线直径，钩宽，钩变形，钩不居中</c>
<l>        detectTop (Image, WindowHandle, input_Scale_1, input_Scale_2, input_Scale_3, input_Scale_4, BaoluoDiameterUp, BaoluoDiameterDown, GouWidthUp, GouWidthDown, Result)</l>
<l>        if(Result==0)</l>
<l>            OKNUM := OKNUM+1</l>
<l>        endif</l>
<c>    </c>
<l>    endfor</l>
<l>elseif(workPostion==1)//第一工位第4张图片处理</l>
<l>    list_image_files(\
   'D:/Images/Top2/Bad'     ,\
                     'default', [], ImageFiles)</l>
<c>    </c>
<l>    tuple_length (ImageFiles, Length)</l>
<l>    for Index := 0 to Length-1 by 1</l>
<c>        </c>
<l>        read_image(Image, ImageFiles[Index])</l>
<c>    </c>
<l>        detectTop2(Image, WindowHandle, prav2_1, prav2_2, prav2_3, prav2_4, prav2_5, prav2_6, prav2_7, prav2_8, Result)</l>
<l>        if(Result==0)</l>
<l>            OKNUM := OKNUM+1</l>
<l>        endif</l>
<l>    endfor</l>
<c>    *     'd:/Images/Side/All/',\
    *     'd:/Images/Side/Bad/',\
    *     'm:/胜克换向器/DS052J-H/2020-04-05/Bad/'      ,</c>
<l>elseif(workPostion==2)//第二工位</l>
<l>    list_image_files(\
                     'd:/Images/Side/Bad/',\
                     'default', [], ImageFiles)</l>
<c>    </c>
<l>    tuple_length (ImageFiles, Length)</l>
<l>    for Index := 0 to Length-1 by 1</l>
<c>        </c>
<l>        read_image(Image, ImageFiles[Index])</l>
<c>    </c>
<c>        </c>
<c>        *检测槽内异物，包络线直径，钩宽，钩变形，钩不居中</c>
<l>        detectSide (Image, WindowHandle, input_Scale_1s, input_Scale_2s, input_Scale_3s, input_Scale_4s, CaoWidthUp, CaoWidthDown, YiWuArea, YiWuHeight, Result)</l>
<c>        </c>
<l>        if(Result==0)</l>
<l>            OKNUM := OKNUM+1</l>
<l>        endif</l>
<c></c>
<l>    endfor</l>
<l>endif</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="detectTop">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="input_Scale_1" base_type="ctrl" dimension="0"/>
<par name="input_Scale_2" base_type="ctrl" dimension="0"/>
<par name="input_Scale_3" base_type="ctrl" dimension="0"/>
<par name="input_Scale_4" base_type="ctrl" dimension="0"/>
<par name="BaoLuoDiameterUp" base_type="ctrl" dimension="0"/>
<par name="BaoLuoDiameterDown" base_type="ctrl" dimension="0"/>
<par name="GouWidthUp" base_type="ctrl" dimension="0"/>
<par name="GouWidthDown" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Result" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c>* 		output_Result 输出结果定义：</c>
<c>* 		static const int Good				= 0x00;</c>
<c>* 		static const int Bad					= 0x01;</c>
<c>* 		static const int Gou					= 0x02;</c>
<c>* 		static const int Cao					= 0x03;</c>
<c>* 		static const int Liantong			= 0x04;</c>
<c></c>
<l>dev_update_off()</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_line_width(1)</l>
<l>set_display_font (WindowHandle, 11, 'mono', 'false', 'false')</l>
<c></c>
<l>funCorrectImage (Image, imageCorrected0, imageCorrected1, imageCorrected2)</l>
<c></c>
<l>dev_display(imageCorrected0)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>hwnd :=200000</l>
<l>ret1:=0</l>
<l>ret2:=0</l>
<l>ret3:=0</l>
<l>ret4:=0</l>
<l>ret5:=0</l>
<c></c>
<l>* fun1 (imageCorrected1, GouDings, circlrRow, circlrColumn, ret1, MaxDif)</l>
<c></c>
<c>*外径跳动检测,找到非畸变图片</c>
<l>fun5 (imageCorrected0, imageCorrected1, imageCorrected2, hwnd, input_Scale_1, (BaoLuoDiameterDown), (BaoLuoDiameterUp), ret5)</l>
<l>if(ret5&gt;0)</l>
<l>    if(ret5==10)</l>
<l>        imageCorrectedSTD:=imageCorrected1</l>
<l>        imageCorrectedSTD1:=imageCorrected0</l>
<l>    elseif(ret5==20)</l>
<l>        imageCorrectedSTD:=imageCorrected2</l>
<l>        imageCorrectedSTD1:=imageCorrected0</l>
<l>    elseif(ret5==21)</l>
<l>        imageCorrectedSTD:=imageCorrected2</l>
<l>        imageCorrectedSTD1:=imageCorrected1</l>
<l>    endif</l>
<l>    ret5:=0</l>
<l>endif</l>
<c></c>
<c></c>
<l>if(ret5==0)</l>
<c>    *包络线直径</c>
<l>    fun4 (imageCorrectedSTD, region4, hwnd, input_Scale_1, input_Scale_4, (BaoLuoDiameterDown), (BaoLuoDiameterUp), ret4)</l>
<c></c>
<c>    *钩宽，钩变形</c>
<l>    fun2 (imageCorrectedSTD, gouTopRegions, region2, hwnd, GouWidthDown, GouWidthUp, ret2)</l>
<c>    </c>
<c>    *钩宽不合格，钩间距离检测无意义，直接跳过。在外径不合格时也跳过。</c>
<l>    if(ret2==0 and ret4==0 )</l>
<c>        *钩不居中、钩偏，在堵槽情况下，模拟套环来检测</c>
<l>        fun3 (imageCorrectedSTD, imageCorrectedSTD1, gouTopRegions, region3, hwnd, input_Scale_2, input_Scale_3, ret3)</l>
<l>    endif</l>
<l>endif</l>
<l>Result := 0</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<c>***此处第二版粘铜区分下料注意注意：同时有多种不良时最后反馈结果为粘铜</c>
<c>***2个工位检测有多种不良结果时，最后反应为粘铜</c>
<l>if(ret5&lt;0)</l>
<l>    Result := 2</l>
<l>    if(ret5 == -10)</l>
<l>        disp_message(hwnd, 'NG 震动失真', 'window', 150, 10, 'red', 'true')</l>
<l>    else</l>
<l>        disp_message(hwnd, 'NG 钩长度', 'window', 150, 10, 'red', 'true')</l>
<l>        ret4:=-10</l>
<l>    endif</l>
<l>endif</l>
<l>if(ret2&lt;0)</l>
<l>    Result := 2</l>
<l>    disp_message(hwnd, 'NG 钩宽度', 'window', 60, 10, 'red', 'true')</l>
<l>endif</l>
<l>if(ret3&lt;0)</l>
<l>    Result := 2</l>
<l>    disp_message(hwnd, 'NG 钩偏钩扭', 'window', 90, 10, 'red', 'true')</l>
<l>endif</l>
<l>if(ret4&lt;0)</l>
<l>    Result := 2</l>
<l>    disp_message(hwnd, 'NG 钩长度', 'window', 120, 10, 'red', 'true')</l>
<l>endif</l>
<l>if(ret1&lt;0)</l>
<l>    Result := 4</l>
<l>    disp_message(hwnd, 'NG 槽内异物', 'window', 30, 10, 'red', 'true')</l>
<l>endif</l>
<l>if(ret1+ret2+ret3+ret4+ret5==0)</l>
<l>    set_display_font (WindowHandle, 20, 'mono', 'false', 'false')</l>
<l>    disp_message(hwnd, 'OK-良品', 'window', 40, 30, 'blue', 'true')</l>
<l>endif</l>
<l>    set_display_font (WindowHandle, 11, 'mono', 'false', 'false')</l>
<c>    </c>
<l>    disp_message(200000, 'argv:'\
                         +input_Scale_1+' '\
                     +input_Scale_2+' '\
                     +input_Scale_3+' '\
                     +input_Scale_4+' '\
                     +BaoLuoDiameterUp+' '\
                     +BaoLuoDiameterDown+' '\
                     +GouWidthUp+' '\
                     +GouWidthDown+' '\
, 'window', 0, 200, 'black', 'true')</l>
<c></c>
<l>disp_message(200000, '粘'+input_Scale_1+'宽'+input_Scale_1+'中'+input_Scale_1+'经'+input_Scale_1, \
'window', 20, 0, 'black', 'true')</l>
<c></c>
<c></c>
<l>stop()</l>
<l>return ()</l>
<c></c>
<c></c>
<c></c>
</body>
<docu id="detectTop">
<parameters>
<parameter id="BaoLuoDiameterDown"/>
<parameter id="BaoLuoDiameterUp"/>
<parameter id="GouWidthDown"/>
<parameter id="GouWidthUp"/>
<parameter id="Image"/>
<parameter id="Result"/>
<parameter id="WindowHandle"/>
<parameter id="input_Scale_1"/>
<parameter id="input_Scale_2"/>
<parameter id="input_Scale_3"/>
<parameter id="input_Scale_4"/>
</parameters>
</docu>
</procedure>
<procedure name="fun1">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="GouDings" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="circlrRow" base_type="ctrl" dimension="0"/>
<par name="circlrColumn" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret1" base_type="ctrl" dimension="0"/>
<par name="MaxDif" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>ret1:=0</l>
<c></c>
<l>connection(GouDings, ConnectedRegions)</l>
<l>select_obj(ConnectedRegions, ObjectSelected, 1)</l>
<l>area_center(ObjectSelected, Area, Row, Column)</l>
<l>line_orientation(Row, Column, circlrRow, circlrColumn, StartPhi)</l>
<c></c>
<l>StartPhi0:=deg(StartPhi)</l>
<l>EedPhi:=rad(360-StartPhi0)</l>
<c></c>
<c></c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[1,1]" as_ord="1">* Measure 01: Code generated by Measure 01</c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[2,1]" as_ord="1">* Measure 01: Prepare measurement</c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,1]" as_ord="2">AmplitudeThreshold := 80</l>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,1]" as_ord="3">RoiWidthLen2 := 25</l>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,1]" as_ord="4">set_system ('int_zooming', 'true')</l>
<c as_id="measure1d" as_name="Measure 01" as_grp="[2,2]" as_ord="1">* Measure 01: Coordinates for circular arc Measure 01 [0]</c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,2]" as_ord="2">ArcRow_Measure_01_0 := circlrRow</l>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,2]" as_ord="3">ArcColumn_Measure_01_0 := circlrColumn</l>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,2]" as_ord="4">ArcRadius_Measure_01_0 := 1145</l>
<l>gen_circle(Circle, ArcRow_Measure_01_0, ArcColumn_Measure_01_0, ArcRadius_Measure_01_0)</l>
<c></c>
<l>ArcAngleStart_Measure_01_0 := StartPhi</l>
<l>ArcAngleExtent_Measure_01_0 := -6.28//</l>
<c as_id="measure1d" as_name="Measure 01" as_grp="[2,3]" as_ord="1">* Measure 01: Create measure for circular arc Measure 01 [0]</c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[2,3]" as_ord="2">* Measure 01: Attention: This assumes all images have the same size!</c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[2,3]" as_ord="3">gen_measure_arc (ArcRow_Measure_01_0, ArcColumn_Measure_01_0, ArcRadius_Measure_01_0, ArcAngleStart_Measure_01_0, ArcAngleExtent_Measure_01_0, max2(1, min2(RoiWidthLen2, ArcRadius_Measure_01_0)), 3840, 2748, 'nearest_neighbor', MsrHandle_Measure_01_0)</l>
<c as_id="measure1d" as_name="Measure 01" as_grp="[3,1]" as_ord="1">* Measure 01: ***************************************************************</c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[3,1]" as_ord="2">* Measure 01: * The code which follows is to be executed once / measurement *</c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[3,1]" as_ord="3">* Measure 01: ***************************************************************</c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[3,2]" as_ord="1">* Measure 01: The image is assumed to be made available in the</c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[3,2]" as_ord="2">* Measure 01: variable last displayed in the graphics window</c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[3,2]" as_ord="3">copy_obj (Image, Image, 1, 1)</l>
<c as_id="measure1d" as_name="Measure 01" as_grp="[4,1]" as_ord="1">* Measure 01: Execute measurements</c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[4,3]" as_ord="1">measure_pos (Image, MsrHandle_Measure_01_0, 2, AmplitudeThreshold, 'all', 'all', Row_Measure_01_0, Column_Measure_01_0, Amplitude_Measure_01_0, Distance_Measure_01_0)</l>
<c as_id="measure1d" as_name="Measure 01" as_grp="[4,6]" as_ord="1">* Measure 01: Do something with the results</c>
<c as_id="measure1d" as_name="Measure 01" as_grp="[5,2]" as_ord="1">* Measure 01: Clear measure when done</c>
<l as_id="measure1d" as_name="Measure 01" as_grp="[5,2]" as_ord="2">close_measure (MsrHandle_Measure_01_0)</l>
<c></c>
<c></c>
<c></c>
<l>distanceGous:=[]</l>
<c></c>
<l>tuple_length(Distance_Measure_01_0,Length)</l>
<l>for Index := 0 to Length-1 by 1</l>
<l>    tuple_select(Distance_Measure_01_0, Index, Selected)</l>
<l>    if(Selected&gt;200 )</l>
<l>        distanceGous:=[distanceGous,Selected]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c></c>
<l>ditanceDif:=[]</l>
<l>tuple_length(distanceGous, Length1)</l>
<l>for Index1 := 0 to Length1-1 by 1</l>
<l>    tuple_select(distanceGous, Index1, Selected)</l>
<l>    tuple_select(distanceGous, (Index1+1)%Length1, Selected1)</l>
<l>    tuple_abs(Selected1-Selected, Abs)</l>
<l>    ditanceDif:=[ditanceDif,Abs]</l>
<l>    if(Abs&gt;30)//</l>
<c>        </c>
<l>        ret1:=Index1+1</l>
<l>        break</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>tuple_max(ditanceDif, MaxDif)</l>
<c></c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="fun1">
<parameters>
<parameter id="GouDings"/>
<parameter id="Image"/>
<parameter id="MaxDif"/>
<parameter id="circlrColumn"/>
<parameter id="circlrRow"/>
<parameter id="ret1"/>
</parameters>
</docu>
</procedure>
<procedure name="fun4">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region4" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="input_Scale_1" base_type="ctrl" dimension="0"/>
<par name="input_Scale_4" base_type="ctrl" dimension="0"/>
<par name="gouchangMin" base_type="ctrl" dimension="0"/>
<par name="gouchangMax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret4" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>ret4:=0</l>
<l>graythreshold:=160</l>
<l>areathreshold := 1500</l>
<l>diameterMax := 2800</l>
<l>diameterMin := 1365*2</l>
<l>areaoffset := 500000</l>
<l>tongPianRadRadius:=998//铜片构成的圆的大致半径</l>
<l>gouCount:=22//钩的数量</l>
<c></c>
<c></c>
<c></c>
<l>dev_set_color('blue')</l>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<l>threshold (Image, Regions, 0, graythreshold)</l>
<l>connection(Regions, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<c>*面积判断</c>
<l>region_features(SelectedRegions, 'area', areaValue)</l>
<l>calculatedArea:=3.14*tongPianRadRadius*tongPianRadRadius</l>
<l>if(areaValue&lt;calculatedArea-areaoffset or areaValue&gt;calculatedArea+areaoffset)</l>
<l>    disp_message(hwnd, 'topfun4 选择整体区域面积eorror', 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>    ret4 := -1</l>
<l>    return()</l>
<l>endif</l>
<l>fill_up(SelectedRegions, RegionFillUp)</l>
<l>reduce_domain(Image, RegionFillUp, ImageReduced)</l>
<l>threshold (ImageReduced, Regions1, graythreshold, 255)</l>
<l>connection(Regions1, ConnectedRegions1)</l>
<l>select_shape_std(ConnectedRegions1, SelectedRegions2, 'max_area', 70)</l>
<l>area_center(SelectedRegions2, Area, Row, Column)</l>
<c>*2019-07-2改 有钩顶面反光造成白色 填充为黑色</c>
<l>* dilation_circle(SelectedRegions2, RegionDilation, 80)</l>
<l>* paint_region(RegionDilation, Image, ImageResult, 30, 'fill')</l>
<c>**gen_circle(Circle0, Row, Column, 5)</c>
<l>erosion_circle(RegionFillUp, RegionErosion, 30)</l>
<l>paint_region(RegionErosion, Image, ImageResult, 10, 'fill')</l>
<c></c>
<l>gen_circle(Circle, Row, Column, tongPianRadRadius+27)</l>
<l>difference(SelectedRegions, Circle, RegionDifference)</l>
<l>gen_region_points(Region0, Row, Column)</l>
<c></c>
<l>opening_circle(RegionDifference, RegionOpening, 8)</l>
<l>connection(RegionOpening, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, ConnectedRegions2, 'area', 'and', 9000, 28000)</l>
<l>count_obj(ConnectedRegions2, Number)</l>
<l>circleTimes :=gouCount/2</l>
<l>if(Number!=gouCount)</l>
<l>    disp_message(hwnd, 'topfun4 提取钩部区域数量 ！='+gouCount, 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>    ret4 := -2</l>
<l>    if(Number%2=1)</l>
<l>        circleTimes := (Number+1)/2</l>
<l>    endif</l>
<l>    *return()</l>
<l>endif</l>
<c></c>
<c>    </c>
<c>    </c>
<l>opening_circle(RegionFillUp, RegionOpening1, 800)</l>
<c>    </c>
<l>gen_circle(CircleSTD0, Row, Column, tongPianRadRadius-2)</l>
<l>gen_circle(CircleSTD1, Row, Column, tongPianRadRadius+202)</l>
<c></c>
<l>dev_display(CircleSTD1)</l>
<c></c>
<l>twoOutGouDiameterChangedAll:=[]</l>
<l>GouRadiusRight:=[]</l>
<l>GouRadiusLeft:=[]</l>
<l>gen_empty_region(gouRadiusLineRight)</l>
<l>gen_empty_region(gouRadiusLineLeft)</l>
<c></c>
<c></c>
<c></c>
<l>select_obj(ConnectedRegions2, ObjectSelected1, 1)</l>
<l>shape_trans(ObjectSelected1, RegionTrans, 'outer_circle')</l>
<l>dilation_circle(RegionTrans, circleMudle, 50)</l>
<c></c>
<l>for Index := 1 to circleTimes by 1</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -rad(360/22*(Index-1)), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(circleMudle, GouOuterCircle0, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(180), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(GouOuterCircle0, GouOuterCircle1, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    union2(GouOuterCircle0, GouOuterCircle1, GouOuterCircle)</l>
<l>    intersection(GouOuterCircle, ConnectedRegions2, TwoSymmetryGous)</l>
<l>    region_features(TwoSymmetryGous, 'area', TwoSymmetryGousArea)</l>
<l>    if(TwoSymmetryGousArea&lt;22000)</l>
<l>        disp_message(hwnd, 'topfun4 未找到对称区域', 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>        ret4 := -3</l>
<l>    endif</l>
<l>    shape_trans(TwoSymmetryGous, TwoSymmetryGousConvex, 'convex')</l>
<l>    opening_circle(TwoSymmetryGousConvex, TwoSymmetryGousOpened, 30)</l>
<l>    region_features(TwoSymmetryGousOpened, 'max_diameter', twoOutGouDiameter)</l>
<c>    </c>
<c>    *矫正</c>
<l>*     intersection(TwoSymmetryGousConvex, RegionOpening1, RegionIntersection1)</l>
<l>*     region_features(RegionIntersection1, 'max_diameter', Value)</l>
<l>*     JiaoZhengValue:=994*2-Value</l>
<l>    JiaoZhengValue:=0</l>
<c>    </c>
<c>    *半径线条及其长度</c>
<c>    *right-up</c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle0, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)</l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionRight)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineRight, RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionRight, 'max_diameter', Value1)</l>
<l>    GouRadiusRight:=[GouRadiusRight,Value1]</l>
<c>    </c>
<c>    </c>
<c>    *left-down</c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle1, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)    </l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionLeft)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineLeft, RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionLeft, 'max_diameter', Value1)</l>
<l>    GouRadiusLeft:=[GouRadiusLeft,Value1]</l>
<c></c>
<l>    union2(RegionIntersectionRight, RegionIntersectionLeft, diameterRegion1)</l>
<c></c>
<c>    *直径长度判断</c>
<l>    twoOutGouDiameterChanged :=( twoOutGouDiameter + JiaoZhengValue+0.0)* input_Scale_1*0.011736</l>
<l>    if(twoOutGouDiameterChanged&lt;gouchangMin-0.00 or twoOutGouDiameterChanged&gt;gouchangMax+0.00)</l>
<l>        msgShowColor := 'red'</l>
<l>        concat_obj(EmptyRegion, diameterRegion1, EmptyRegion)</l>
<l>    else</l>
<l>        if(gouchangMin-twoOutGouDiameterChanged&lt;=0.00 and gouchangMin-twoOutGouDiameterChanged&gt;0)</l>
<l>            twoOutGouDiameterChanged := gouchangMin</l>
<l>        elseif(twoOutGouDiameterChanged-gouchangMax&lt;=0.00 and twoOutGouDiameterChanged-gouchangMax&gt;0)</l>
<l>            twoOutGouDiameterChanged := gouchangMax</l>
<l>        endif</l>
<l>        dev_set_color('green')</l>
<l>        msgShowColor := 'blue'</l>
<l>        dev_display(diameterRegion1)</l>
<l>    endif</l>
<l>    twoOutGouDiameterChangedAll:=[twoOutGouDiameterChangedAll,twoOutGouDiameterChanged]</l>
<c>    </c>
<c>    </c>
<c>    *外径数值显示</c>
<l>    area_center(GouOuterCircle0, Area3, Row3, Column3)</l>
<l>    tuple_sqrt ((Row-Row3)*(Row-Row3)+(Column-Column3)*(Column-Column3), cccc)</l>
<l>    sina:=(Row-Row3)/cccc</l>
<l>    cosa:=(Column-Column3)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa+Index*6</l>
<l>    rowDispPoint:=Row-rowOffset-30</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<c>    </c>
<c>    </c>
<l>    SZtwoOutGouDiameterChanged := twoOutGouDiameterChanged$'.4'</l>
<l>    SZJiaoZhengValue := JiaoZhengValue$'.3'</l>
<l>    disp_message(hwnd, (SZtwoOutGouDiameterChanged)+ ' mm', 'window', (rowDispPoint)/h, \
                     (columnDispPoint)/w, msgShowColor, 'false')</l>
<l>endfor</l>
<c></c>
<c>*当直径大于且靠近最小标准值时，与它相邻两半径都明显大于它时也判为凹角（钩外径小）</c>
<c>*上下限像素值</c>
<l>gouRaMinPix:=gouchangMin/(input_Scale_1*0.011736)/2</l>
<l>gouRaMaxPix:=gouchangMax/(input_Scale_1*0.011736)/2</l>
<c></c>
<l>union1(EmptyRegion, region4)</l>
<l>region_features(region4, 'area', errorRgnArea)</l>
<l>if(errorRgnArea==0 and ret4==0)</l>
<l>    tuple_concat(GouRadiusRight, GouRadiusLeft, GouRadiusAll)</l>
<l>    tuple_median(GouRadiusAll, GouRadiusMedian)</l>
<l>    tuple_mean(GouRadiusAll, GouRadiusMean)</l>
<l>    concat_obj(gouRadiusLineRight, gouRadiusLineLeft, gouRadiusLineAll)</l>
<l>    for Index1 := 0 to gouCount-1 by 1</l>
<l>        *if(GouRadiusAll[Index1]&lt;GouRadiusMedian-5 or GouRadiusAll[Index1]&gt;GouRadiusMedian+5)</l>
<l>         if(GouRadiusAll[Index1]&lt;gouRaMinPix-3 or GouRadiusAll[Index1]&gt;gouRaMaxPix+3)  // </l>
<l>            Index1Last:=(Index1-1+22)%22</l>
<l>            Index1Next:=(Index1+1)%22</l>
<l>            a205:=input_Scale_4//对在公差临界值附近的半径使用较小的半径差阈值</l>
<l>            RadiusDifL:=GouRadiusAll[Index1]-GouRadiusAll[Index1Last]</l>
<l>            RadiusDifN:=GouRadiusAll[Index1]-GouRadiusAll[Index1Next]</l>
<l>            if(RadiusDifL&gt;a205 or\
                RadiusDifL&lt;-a205 or\
                RadiusDifN&gt;a205 or\
                RadiusDifN&lt;-a205)</l>
<c>                *如果</c>
<l>*                 if(twoOutGouDiameterChangedAll[Index1%11]&gt;(gouchangMin+0.08) and twoOutGouDiameterChangedAll[Index1%11]&lt;gouchangMax-0.08)</l>
<l>*                     continue</l>
<l>*                 endif</l>
<l>                select_obj(gouRadiusLineAll, ObjectSelected, Index1+1)</l>
<l>                concat_obj(EmptyRegion, ObjectSelected, EmptyRegion)</l>
<l>                ret4 := -9</l>
<l>            endif</l>
<l>        endif</l>
<l>        if(GouRadiusAll[Index1]&lt;GouRadiusMean-7 or GouRadiusAll[Index1]&gt;GouRadiusMean+7)</l>
<l>            Index1Last:=(Index1-1+22)%22</l>
<l>            Index1Next:=(Index1+1)%22</l>
<l>            a227:=input_Scale_4+3</l>
<l>            RadiusDifL:=GouRadiusAll[Index1]-GouRadiusAll[Index1Last]</l>
<l>            RadiusDifN:=GouRadiusAll[Index1]-GouRadiusAll[Index1Next]</l>
<l>            if(RadiusDifL&gt;a227 or\
                RadiusDifL&lt;-a227 or\
                RadiusDifN&gt;a227 or\
                RadiusDifN&lt;-a227)</l>
<c>                *如果</c>
<l>*                 if(twoOutGouDiameterChangedAll[Index1%11]&gt;(gouchangMin+0.08) and twoOutGouDiameterChangedAll[Index1%11]&lt;gouchangMax-0.08)</l>
<l>*                     continue</l>
<l>*                 endif</l>
<l>                select_obj(gouRadiusLineAll, ObjectSelected, Index1+1)</l>
<l>                concat_obj(EmptyRegion, ObjectSelected, EmptyRegion)</l>
<l>                ret4 := -9</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<l>endif</l>
<c></c>
<l>union1(EmptyRegion, region4)</l>
<l>region_features(region4, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret4==0)</l>
<l>    ret4 := -10</l>
<l>endif</l>
<l>if(ret4 == -9)</l>
<l>    dev_set_color('magenta')</l>
<l>else</l>
<l>    dev_set_color('red')</l>
<l>endif</l>
<c></c>
<l>dev_display(region4)</l>
<c>*hv_hwnd</c>
<l>return ()</l>
<c></c>
</body>
<docu id="fun4">
<parameters>
<parameter id="Image"/>
<parameter id="gouchangMax"/>
<parameter id="gouchangMin"/>
<parameter id="hwnd"/>
<parameter id="input_Scale_1"/>
<parameter id="input_Scale_4"/>
<parameter id="region4"/>
<parameter id="ret4"/>
</parameters>
</docu>
</procedure>
<procedure name="fun3">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="Image1" base_type="iconic" dimension="0"/>
<par name="gouTopRegions" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region3" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="GouTaoWide" base_type="ctrl" dimension="0"/>
<par name="GouGouTaoIntersectionInner_radius" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret3" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>ret3:=0</l>
<l>graythreshold:=160</l>
<l>if (GouTaoWide&lt;=0)</l>
<l>    GouTaoWide := 1</l>
<l>endif</l>
<l>tongPianRadRadius:=998//铜片构成的圆的大致半径</l>
<l>gouCount:=22//钩的数量</l>
<c></c>
<c></c>
<c></c>
<l>dev_set_color('green')</l>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<l>gen_circle (ROI_0, 1377.5, 1873.5, 900)</l>
<l>reduce_domain(Image, ROI_0, ImageReduced1)</l>
<l>threshold (ImageReduced1, Regions2, 54, 254)</l>
<l>connection(Regions2, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectedRegions2, ['circularity','area'], 'and', [0.9303,268349], [1.0917,500000])</l>
<l>count_obj(SelectedRegions2, Number)</l>
<l>if(Number==0)</l>
<l>    disp_message(hwnd, 'topfun3 提取内圆error', 'window', (Height1-400+100)/h, 20, 'red', 'true')</l>
<l>    ret3 := -1</l>
<l>    return()</l>
<l>endif</l>
<l>area_center(SelectedRegions2, Area2, Row, Column)</l>
<l>gen_circle(RegionOpening, Row, Column, 1000)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>ret1:=0</l>
<l>fun1 (Image, gouTopRegions, Row, Column, ret1, MaxDif1)</l>
<l>if(ret1&gt;0)</l>
<l>    disp_message(hwnd, 'topfun3-&gt;fun1 钩：'+(ret1+1)+' maxDifDis='+MaxDif1, 'window', (Height1-600+100)/h, 20, 'red', 'false')</l>
<l>    ret3 := -5</l>
<l>    return()</l>
<l>endif</l>
<l>disp_message(hwnd, 'topfun3-&gt;fun1 钩：'+'x'+' maxDifDis='+MaxDif1, 'window', (Height1-600+100)/h, 20, 'magenta', 'false')</l>
<l>if(MaxDif1&lt;13)</l>
<l>    GouTaoWide:=GouTaoWide+2</l>
<l>endif</l>
<c></c>
<l>*read_image(Image2, 'C:/Users/Administrator/Desktop/pic/Image_20200423152620473.bmp')</l>
<c></c>
<c></c>
<c>*执行到此处时钩宽度一定合格</c>
<c>*长度判断缩放阀值</c>
<c></c>
<c>*钩偏检测改良版，通过钩间距离（钩间区域的宽度）来判断还是不行，改用套钩工具的原理检测</c>
<l>gen_circle(CircleCheckBaseIn, Row, Column, 1060)</l>
<l>gen_circle(CircleCheckBaseOut, Row, Column, 1210)</l>
<l>difference(CircleCheckBaseOut, CircleCheckBaseIn, CircleCheckBaseCircle)</l>
<l>connection(gouTopRegions, gouTopConnectedRegions)</l>
<c></c>
<c>*建立外框</c>
<l>select_obj(gouTopConnectedRegions, ObjectSelectedBase, 1)</l>
<l>area_center(ObjectSelectedBase, Area1, Row1, Column1)</l>
<c></c>
<l>tuple_sqrt ((Row-Row1)*(Row-Row1)+(Column-Column1)*(Column-Column1), cccc)</l>
<c></c>
<l>sina:=(Row-Row1)/cccc</l>
<l>cosa:=(Column-Column1-15)/cccc//-x右旋幅度</l>
<l>rowOffset:=1250*sina</l>
<l>columnOffset:=1250*cosa</l>
<c></c>
<l>gen_region_line(RegionLinesBase, Row, Column, Row-rowOffset, Column-columnOffset)</l>
<l>gen_empty_region(gouRegionSTD0)</l>
<l>concat_obj(gouRegionSTD0, RegionLinesBase, gouRegionSTD0)</l>
<l>for Index := 1 to gouCount-1 by 1</l>
<l>    ratateNum:=rad(360)/22*Index</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, ratateNum, Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(RegionLinesBase, RegionLinesBaseaffined, HomMat2DRotate, 'constant')</l>
<l>    concat_obj(gouRegionSTD0, RegionLinesBaseaffined, gouRegionSTD0)</l>
<l>endfor</l>
<l>union1(gouRegionSTD0, gouRegionSTD1)</l>
<l>difference(gouRegionSTD1, CircleCheckBaseIn, RegionDifference)</l>
<c>*钩套内孔宽度</c>
<l>dilation_circle(RegionDifference, gouTaoBaseIn, GouTaoWide)</l>
<l>dilation_circle(gouTaoBaseIn, gouTaoBaseOut, 20)</l>
<l>difference(gouTaoBaseOut, gouTaoBaseIn, gouTaoOutCircle)</l>
<l>intersection(gouTaoOutCircle, CircleCheckBaseCircle, gouTao)</l>
<c></c>
<c></c>
<l>isOkMark:=0</l>
<l>isDebugMark:=  0</l>
<l>minRInIteration:=100</l>
<l>gen_empty_region(minRR)</l>
<l>minRRInfo:=[]</l>
<l>for Index := 0 to 1.5 by 0.05</l>
<l>    ratateNum:=rad(Index)</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, ratateNum, Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(gouTao, gouTaoNow, HomMat2DRotate, 'nearest_neighbor')</l>
<c>    *第一张图片处理</c>
<l>    reduce_domain(Image, gouTaoNow, ImageReduced)</l>
<l>    threshold (ImageReduced, Regions1, 0, 150)</l>
<l>    connection(Regions1, ConnectedRegions1)</l>
<l>    region_features(ConnectedRegions1, 'inner_radius', ValueIR)</l>
<l>    tuple_max(ValueIR, Max)</l>
<l>    if(Max&gt;=GouGouTaoIntersectionInner_radius)</l>
<l>        tuple_find(ValueIR, Max, Indices)</l>
<l>        select_obj(ConnectedRegions1, SelectedRegions1, Indices+1)</l>
<l>        select_shape_std(SelectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<l>    else</l>
<l>        select_shape_std(ConnectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<l>    endif</l>
<l>    region_features(SelectedRegions1, ['area','inner_radius','max_diameter'], Value)</l>
<l>    if(Value[1]&lt;minRInIteration)</l>
<l>        union1(SelectedRegions1, minRR)</l>
<l>        minRInIteration:=Value[1]</l>
<l>        minRRInfo:=Value</l>
<l>    endif</l>
<l>    if(isDebugMark)</l>
<l>        dev_clear_window()</l>
<l>        dev_set_color('green')</l>
<l>        dev_display(Image)</l>
<l>        dev_display(gouTaoNow)</l>
<l>        dev_set_color('red')</l>
<l>        dilation_circle(SelectedRegions1, RegionDilation, 15)</l>
<l>        dev_display(RegionDilation)</l>
<l>        disp_message(hwnd, 'topfun3 钩套交Msg area/inR/maxD='+Value[0]+'/'+Value[1]+'/'+Value[2], 'window', (Height1-400+100)/h, 20, 'blue', 'true')</l>
<c>        </c>
<l>        stop()</l>
<l>    endif</l>
<c>    *判断</c>
<l>    if(Value[1]&lt;GouGouTaoIntersectionInner_radius)</l>
<c>        </c>
<l>        if(isDebugMark)</l>
<l>            disp_message(hwnd, '钩居中,退出循环------&gt;&gt;&gt;&gt;&gt;', 'window', (Height1-400+100)/h, 20, 'blue', 'true')</l>
<l>            stop()</l>
<l>        endif</l>
<c>        </c>
<l>        isOkMark:=1</l>
<l>        disp_message(hwnd, 'topfun3 钩套交1 Msg area/inR/maxD='+Value[0]+'/'+Value[1]+'/'+Value[2], 'window', (Height1-400+100)/h, 20, 'magenta', 'false')</l>
<l>        break</l>
<l>    endif</l>
<l>    if(Value[0]&lt;50 and Value[1]&lt;GouGouTaoIntersectionInner_radius+1)</l>
<c>        </c>
<l>        if(isDebugMark)</l>
<l>            disp_message(hwnd, '钩居中,退出循环------&gt;&gt;&gt;&gt;&gt;', 'window', (Height1-400+100)/h, 20, 'blue', 'true')</l>
<l>            stop()</l>
<l>        endif</l>
<c>        </c>
<l>        isOkMark:=1</l>
<l>        disp_message(hwnd, 'topfun3 钩套交1 Msg area/inR/maxD='+Value[0]+'/'+Value[1]+'/'+Value[2], 'window', (Height1-400+100)/h, 20, 'magenta', 'false')</l>
<l>        break</l>
<l>    endif</l>
<c>    </c>
<c>    *第二张图片处理</c>
<l>    reduce_domain(Image1, gouTaoNow, ImageReduced)</l>
<l>    threshold (ImageReduced, Regions1, 0, 100)</l>
<l>    connection(Regions1, ConnectedRegions1)</l>
<l>    region_features(ConnectedRegions1, 'inner_radius', ValueIR)</l>
<l>    tuple_max(ValueIR, Max)</l>
<l>    if(Max&gt;=GouGouTaoIntersectionInner_radius)</l>
<l>        tuple_find(ValueIR, Max, Indices)</l>
<l>        select_obj(ConnectedRegions1, SelectedRegions1, Indices+1)</l>
<l>        select_shape_std(SelectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<l>    else</l>
<l>        select_shape_std(ConnectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<l>    endif</l>
<l>    region_features(SelectedRegions1, ['area','inner_radius','max_diameter'], Value)</l>
<l>    if(Value[1]&lt;minRInIteration)</l>
<l>        union1(SelectedRegions1, minRR)</l>
<l>        minRInIteration:=Value[1]</l>
<l>        minRRInfo:=Value</l>
<l>    endif</l>
<l>    if(isDebugMark)</l>
<l>        dev_clear_window()</l>
<l>        dev_set_color('green')</l>
<l>        dev_display(Image)</l>
<l>        dev_display(gouTaoNow)</l>
<l>        dev_set_color('red')</l>
<l>        dilation_circle(SelectedRegions1, RegionDilation, 15)</l>
<l>        dev_display(RegionDilation)</l>
<l>        disp_message(hwnd, 'topfun3 钩套交二Msg area/inR/maxD='+Value[0]+'/'+Value[1]+'/'+Value[2], 'window', (Height1-400+100)/h, 20, 'blue', 'true')</l>
<c>        </c>
<l>        stop()</l>
<l>    endif</l>
<c>    *判断</c>
<l>    if(Value[1]&lt;GouGouTaoIntersectionInner_radius)</l>
<c>        </c>
<l>        if(isDebugMark)</l>
<l>            disp_message(hwnd, '钩居中,退出循环二------&gt;&gt;&gt;&gt;&gt;', 'window', (Height1-400+100)/h, 20, 'blue', 'true')</l>
<l>            stop()</l>
<l>        endif</l>
<c>        </c>
<l>        isOkMark:=1</l>
<l>        disp_message(hwnd, 'topfun3 钩套交2 Msg area/inR/maxD='+Value[0]+'/'+Value[1]+'/'+Value[2], 'window', (Height1-400+100)/h, 20, 'magenta', 'false')</l>
<l>        break</l>
<l>    endif</l>
<l>    if(Value[0]&lt;50 and Value[1]&lt;GouGouTaoIntersectionInner_radius+1)</l>
<c>        </c>
<l>        if(isDebugMark)</l>
<l>            disp_message(hwnd, '钩居中,退出循环二------&gt;&gt;&gt;&gt;&gt;', 'window', (Height1-400+100)/h, 20, 'blue', 'true')</l>
<l>            stop()</l>
<l>        endif</l>
<c>        </c>
<l>        isOkMark:=1</l>
<l>        disp_message(hwnd, 'topfun3 钩套交2 Msg area/inR/maxD='+Value[0]+'/'+Value[1]+'/'+Value[2], 'window', (Height1-400+100)/h, 20, 'magenta', 'false')</l>
<l>        break</l>
<l>    endif</l>
<c>    *对循环的优化</c>
<l>    circleStep:=Value[1]-(GouGouTaoIntersectionInner_radius+1)</l>
<l>    if(circleStep&gt;0)</l>
<l>        Index := Index +0.05*circleStep</l>
<l>    endif</l>
<c>    </c>
<l>endfor</l>
<c></c>
<l>if(isDebugMark)</l>
<l>    disp_message(hwnd, '退出循环----&gt;&gt;&gt;&gt;&gt;', 'window', (Height1-400+100)/h, 20, 'blue', 'true')</l>
<l>    stop()</l>
<l>endif</l>
<c></c>
<l>if(isOkMark==0)</l>
<l>    concat_obj(minRR, EmptyRegion, EmptyRegion)</l>
<l>    *dilation_circle(minRR, minRR_D, 15)</l>
<l>    dilation_rectangle1(minRR, minRR_D, 20, 20)</l>
<l>    dev_set_color('magenta')</l>
<l>    dev_display(minRR_D)</l>
<l>    disp_message(hwnd, 'topfun3 钩套交Msg area/inR/maxD='+minRRInfo[0]+'/'+minRRInfo[1]+'/'+minRRInfo[2], 'window', (Height1-400+100)/h, 20, 'red', 'false')</l>
<l>endif</l>
<c></c>
<l>union1(EmptyRegion, region3)</l>
<l>region_features(region3, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret3==0)</l>
<l>    ret3 := -10</l>
<l>    dev_set_color('red')</l>
<l>    dev_display(region3)</l>
<l>endif</l>
<c>*hv_hwnd</c>
<l>return ()</l>
</body>
<docu id="fun3">
<parameters>
<parameter id="GouGouTaoIntersectionInner_radius"/>
<parameter id="GouTaoWide"/>
<parameter id="Image"/>
<parameter id="Image1"/>
<parameter id="gouTopRegions"/>
<parameter id="hwnd"/>
<parameter id="region3"/>
<parameter id="ret3"/>
</parameters>
</docu>
</procedure>
<procedure name="fun2">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="gouTopRegions" base_type="iconic" dimension="0"/>
<par name="region2" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="goukuanMin" base_type="ctrl" dimension="0"/>
<par name="goukuanMax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>ret2:=0</l>
<l>graythreshold:=60</l>
<l>areathreshold := 1500</l>
<l>areaoffset := 500000</l>
<l>goukuanoffset := 15</l>
<l>tongPianRadRadius:=998//铜片构成的圆的大致半径</l>
<l>gouCount:=22//钩的数量</l>
<c></c>
<l>dev_set_color('green')</l>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<l>threshold (Image, Regions, 0, graythreshold)</l>
<l>connection(Regions, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<c>*面积判断</c>
<l>region_features(SelectedRegions, 'area', areaValue)</l>
<l>calculatedArea:=3.14*tongPianRadRadius*tongPianRadRadius</l>
<l>if(areaValue&lt;calculatedArea-areaoffset or areaValue&gt;calculatedArea+areaoffset)</l>
<l>    disp_message(hwnd, 'topfun2 选择整体区域面积eorror', 'window', (Height1-400+100)/h, 20, 'red', 'true')</l>
<l>    ret2 := -1</l>
<l>    return()</l>
<l>endif</l>
<l>fill_up(SelectedRegions, RegionFillUp)</l>
<l>reduce_domain(Image, RegionFillUp, ImageReduced)</l>
<l>threshold (ImageReduced, Regions1, graythreshold, 255)</l>
<l>connection(Regions1, ConnectedRegions1)</l>
<l>select_shape_std(ConnectedRegions1, SelectedRegions2, 'max_area', 70)</l>
<l>area_center(SelectedRegions2, Area, Row, Column)</l>
<l>gen_region_points(Region0, Row, Column)</l>
<l>gen_circle(Circle, Row, Column, tongPianRadRadius+112)</l>
<c></c>
<l>difference(SelectedRegions, Circle, RegionDifference)</l>
<l>opening_circle(RegionDifference, RegionOpening, 9)</l>
<l>connection(RegionOpening, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, ConnectedRegions2, 'area', 'and', 1500, 12000)</l>
<l>count_obj(ConnectedRegions2, Number)</l>
<l>if(Number!=gouCount)</l>
<l>    disp_message(hwnd, 'topfun2 提取钩顶区域数量 ！='+gouCount, 'window', (Height1-400+100)/h, 20, 'red', 'true')</l>
<l>    ret2 := -2</l>
<l>    return()</l>
<l>endif</l>
<l>union1(ConnectedRegions2, gouTopRegions)//返回钩顶区域供钩偏检测使用 </l>
<c></c>
<l>erosion_circle(Circle, RegionErosion1, 70)</l>
<l>erosion_circle(Circle, RegionErosion2, 125)</l>
<l>difference(RegionErosion1, RegionErosion2, RegionDifference1)</l>
<l>reduce_domain(Image, RegionDifference1, ImageReduced1)</l>
<l>threshold (ImageReduced1, Regions2, 0, 50)</l>
<l>opening_circle(Regions2, RegionOpening1, 20)</l>
<l>connection(RegionOpening1, ConnectedRegions3)</l>
<l>select_shape (ConnectedRegions3, ConnectedRegions3, 'area', 'and', 4000, 7000)</l>
<l>count_obj(ConnectedRegions3, Number1)</l>
<l>if(Number1!=gouCount)</l>
<l>    disp_message(hwnd, 'topfun2 提取钩跟区域数量 ！='+gouCount, 'window', (Height1-400+100)/h, 20, 'red', 'true')</l>
<l>    ret2 := -3</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*钩宽范围判断</c>
<l>tuple0:=[]</l>
<l>tuple1:=[]</l>
<c></c>
<l>for Index := 1 to gouCount by 1</l>
<c>    *钩顶宽</c>
<l>    select_obj(ConnectedRegions2, ObjectSelected, Index)</l>
<l>    union2(ObjectSelected, Region0, RegionUnion)</l>
<l>    region_features(RegionUnion, 'rect2_len2', len2Value)</l>
<l>    *len2Value := round(len2Value)*2*0.011736//不应该用round</l>
<l>    len2Value := len2Value*2*0.011736</l>
<l>    tuple0:=[len2Value,tuple0]</l>
<l>    errClear:=0.04</l>
<l>    if(len2Value&lt;goukuanMin-errClear or len2Value&gt;goukuanMax+errClear )</l>
<l>        concat_obj(EmptyRegion, ObjectSelected, EmptyRegion)</l>
<l>    endif</l>
<c>    *钩底宽</c>
<l>    select_obj(ConnectedRegions3, ObjectSelected, Index)</l>
<l>    union2(ObjectSelected, Region0, RegionUnion)</l>
<l>    region_features(RegionUnion, 'rect2_len2', len2Value)</l>
<l>    len2Value := round(len2Value)*2*0.011736</l>
<l>    tuple1:=[len2Value,tuple1]</l>
<l>    if(len2Value&lt;goukuanMin-errClear+0.12 or len2Value&gt;goukuanMax+errClear+0.30 )</l>
<l>        concat_obj(EmptyRegion, ObjectSelected, EmptyRegion)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1(EmptyRegion, region2)</l>
<l>region_features(region2, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret2==0)</l>
<l>    ret2 := -10</l>
<l>endif</l>
<c></c>
<l>dev_set_color('red')</l>
<l>dev_display(region2)</l>
<c>*hv_hwnd</c>
<l>return ()</l>
</body>
<docu id="fun2">
<parameters>
<parameter id="Image"/>
<parameter id="gouTopRegions"/>
<parameter id="goukuanMax"/>
<parameter id="goukuanMin"/>
<parameter id="hwnd"/>
<parameter id="region2"/>
<parameter id="ret2"/>
</parameters>
</docu>
</procedure>
<procedure name="detectSide">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="input_Scale_1Goupian" base_type="ctrl" dimension="0"/>
<par name="input_Scale_2" base_type="ctrl" dimension="0"/>
<par name="input_Scale_3" base_type="ctrl" dimension="0"/>
<par name="input_Scale_4" base_type="ctrl" dimension="0"/>
<par name="CaoWidthUp" base_type="ctrl" dimension="0"/>
<par name="CaoWidthDown" base_type="ctrl" dimension="0"/>
<par name="YiWuArea" base_type="ctrl" dimension="0"/>
<par name="YiWuHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Result" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>*Result := ret1+ret2+ret3+ret4</l>
<c>* 		output_Result 输出结果定义：</c>
<c>* 		static const int Good				= 0x00;</c>
<c>* 		static const int Bad					= 0x01;</c>
<c>* 		static const int Gou					= 0x02;</c>
<c>* 		static const int Cao					= 0x03;</c>
<c>* 		static const int Liantong			= 0x04;</c>
<c></c>
<c></c>
<c></c>
<l>dev_update_off()</l>
<l>dev_set_draw('margin')</l>
<l>dev_set_line_width(1)</l>
<c></c>
<l>SideCHH_PingJie(Image, ImagePJ,1080, 2, 0, 180, DownRow)</l>
<c></c>
<l>ret1:=0</l>
<l>ret2:=0</l>
<l>ret3:=0</l>
<l>ret4:=0</l>
<l>ret5:=0</l>
<l>hwnd :=200000</l>
<l>dev_display(ImagePJ)</l>
<c></c>
<l>disp_message (200000, 'argv:'+input_Scale_1Goupian+' '+input_Scale_2+' '+input_Scale_3+' ' +input_Scale_4+' ' +CaoWidthUp+' '  +CaoWidthDown+' ' +YiWuArea+' '+YiWuHeight, 'window', 0, 200, 'black', 'true')</l>
<l>disp_message (200000, '宽'+input_Scale_1Goupian+'粘'+input_Scale_1Goupian+'碰'+input_Scale_1Goupian+'高'+input_Scale_1Goupian+'中'+input_Scale_1Goupian, 'window', 20, 200, 'black', 'true')</l>
<c></c>
<c>*槽宽、槽连续</c>
<l>Sidefun1 (ImagePJ, region1, outRegion1, WindowHandle, CaoWidthDown, CaoWidthUp, ret1)</l>
<l>if(ret1==0 or ret1==-10)</l>
<c>    *粘铜、电木粉</c>
<l>    Sidefun2 (ImagePJ, outRegion1, region2, WindowHandle, YiWuArea, YiWuHeight, ret2)</l>
<c>    </c>
<c>    *片区大划伤、生锈</c>
<l>    Sidefun3 (ImagePJ, outRegion1, region3, WindowHandle, input_Scale_2, ret3)</l>
<c>    </c>
<c>    *钩顶到换向器底部距离（钩右极限位置） </c>
<l>    Sidefun4 (ImagePJ, outRegion1, region4, input_Scale_1Goupian, WindowHandle, ret4, ret5)</l>
<c>    </c>
<c>     *对钩居中的检测（肩上方区域黑色宽度）</c>
<l>*     Sidefun5 (ImagePJ, outRegion1, region5, WindowHandle, input_Scale_1Goupian, ret5)</l>
<l>endif</l>
<c>***此处第二版粘铜区分下料注意注意：同时有多种不良时最后反馈结果为粘铜</c>
<c>***2个工位检测有多种不良结果时，最后反应为粘铜</c>
<l>Result := 0</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<l>if(ret1&lt;0)</l>
<l>    Result := 3</l>
<l>    disp_message(hwnd, 'NG 槽宽度', 'window', 30, 30, 'red', 'true')</l>
<l>endif</l>
<l>if(ret3&lt;0)</l>
<l>    Result := 1</l>
<l>    disp_message(hwnd, 'NG 大碰伤划伤、生锈', 'window', 90, 30, 'red', 'true')</l>
<l>endif</l>
<l>if(ret4&lt;0)</l>
<l>    Result := 2</l>
<l>    disp_message(hwnd, 'NG 钩高度', 'window', 120, 30, 'red', 'true')</l>
<l>endif</l>
<l>if(ret5&lt;0)</l>
<l>    Result := 2</l>
<l>    disp_message(hwnd, 'NG 钩不居中', 'window', 150, 30, 'red', 'true')</l>
<l>endif</l>
<l>if(ret2&lt;0)</l>
<l>    Result := 4</l>
<l>    disp_message(hwnd, 'NG 槽内异物', 'window', 60, 30, 'red', 'true')</l>
<l>endif</l>
<c>*槽内被粘铜堵住导致槽不连续，不进行粘铜检测情况也判位粘铜</c>
<l>if(ret1==-2 or ret1==-3)</l>
<l>    Result := 4</l>
<l>endif</l>
<l>if(ret1+ret2+ret3+ret4+ret5==0)</l>
<l>    set_display_font (WindowHandle, 20, 'mono', 'false', 'false')</l>
<l>    disp_message(hwnd, 'OK-良品', 'window', 40, 30, 'blue', 'true')</l>
<l>endif</l>
<l>set_display_font (WindowHandle, 11, 'mono', 'false', 'false')</l>
<c></c>
<l>stop()</l>
<l>return ()</l>
</body>
<docu id="detectSide">
<parameters>
<parameter id="CaoWidthDown"/>
<parameter id="CaoWidthUp"/>
<parameter id="Image"/>
<parameter id="Result"/>
<parameter id="WindowHandle"/>
<parameter id="YiWuArea"/>
<parameter id="YiWuHeight"/>
<parameter id="input_Scale_1Goupian"/>
<parameter id="input_Scale_2"/>
<parameter id="input_Scale_3"/>
<parameter id="input_Scale_4"/>
</parameters>
</docu>
</procedure>
<procedure name="SideCHH_PingJie">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="TileImage" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="MearsureColCenter" base_type="ctrl" dimension="0"/>
<par name="EdgeOffset" base_type="ctrl" dimension="0"/>
<par name="Offset" base_type="ctrl" dimension="0"/>
<par name="HorProjectionGrayVal" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="DownRow" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>get_image_size(Image, Width, Height)</l>
<c></c>
<l>    TmpCtrl_Row:=800</l>
<l>*     MearsureColCenter := 900</l>
<l>    TmpCtrl_Phi := rad(0)</l>
<l>    TmpCtrl_Len1 := 500</l>
<l>    TmpCtrl_Len2 := 800</l>
<c>    *******</c>
<l>    *gen_rectangle2 (Rectangle, TmpCtrl_Row, MearsureColCenter, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2)</l>
<l>    gen_rectangle1 (Rectangle, 40, 793.5, 1645, 1420)</l>
<l>    gray_projections (Rectangle, Image, 'simple', HorProjection, VertProjection)</l>
<c>    </c>
<c>    ****************</c>
<c>    *HorProjectionGrayVal 传入的参数</c>
<l>     for Index := 0 to |HorProjection| by 1</l>
<l>        if(HorProjection[Index]&lt;HorProjectionGrayVal)</l>
<l>            Index:=Index+EdgeOffset</l>
<l>            if(Index&gt;|HorProjection|-1)</l>
<l>                return()</l>
<l>            endif</l>
<l>            if(HorProjection[Index]&lt;HorProjectionGrayVal)</l>
<l>                break</l>
<l>            endif</l>
<l>        endif</l>
<l>        if(Index==|HorProjection|-1)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>    CutRow:=Index</l>
<l>    if(CutRow&lt;=100)</l>
<l>        CutRow:=CutRow+30+125</l>
<l>    elseif(CutRow&gt;100 and CutRow&lt;240)</l>
<l>        CutRow:=CutRow-100</l>
<l>    else</l>
<l>        CutRow := CutRow-180</l>
<l>    endif</l>
<l>    crop_rectangle1 (Image, ImagePartdown, CutRow, 0, Height-1,Width-1)</l>
<l>    crop_rectangle1 (Image, ImagePartup, 0, 0, CutRow-1+Offset, Width-1)   </l>
<l>    gen_empty_obj(Images)</l>
<l>    concat_obj(Images, ImagePartdown, Images)</l>
<l>    concat_obj(Images, ImagePartup, Images)</l>
<l>    DownRow:=Height-CutRow-Offset</l>
<l>    tile_images_offset (Images, TileImage, [0,DownRow], [0,0], [-1,-1], [-1,-1], [-1,-1], [-1,-1], Width, Height)</l>
<c></c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="SideCHH_PingJie">
<parameters>
<parameter id="DownRow"/>
<parameter id="EdgeOffset"/>
<parameter id="HorProjectionGrayVal"/>
<parameter id="Image"/>
<parameter id="MearsureColCenter"/>
<parameter id="Offset"/>
<parameter id="TileImage"/>
</parameters>
</docu>
</procedure>
<procedure name="Sidefun1">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region1" base_type="iconic" dimension="0"/>
<par name="outRegion1" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="CaoWidthMin" base_type="ctrl" dimension="0"/>
<par name="CaoWidthMax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret1" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>ret1:=0</l>
<c>*单片高度,用于判断槽的连续性</c>
<l>chipHeight :=285</l>
<l>chipWidth0:=1050</l>
<l>dev_set_color('green')</l>
<c></c>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<l>gen_empty_region(outEmptyRegion)</l>
<c></c>
<l>gen_rectangle1 (ROI_0, 21.5, 21.5, 2277.5, 2009.5)</l>
<l>reduce_domain(Image, ROI_0, ImageReduced1)</l>
<l>threshold (ImageReduced1, Regions1, 140, 255)</l>
<l>connection(Regions1, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, SelectedRegions2, 'area', 'and', 70000, 1000000)</l>
<l>union1(SelectedRegions2, RegionUnion)</l>
<l>closing_rectangle1(RegionUnion, RegionClosing2, 20, 150)</l>
<l>fill_up(RegionClosing2, RegionClosing2)</l>
<l>opening_rectangle1(RegionClosing2, RegionOpening3, 500, 1500)</l>
<l>region_features(RegionOpening3, 'column2', PianColumn2)</l>
<l>region_features(RegionOpening3, 'width', PianWidth)</l>
<c></c>
<l>if(0==PianColumn2 or PianColumn2&gt;1900 or PianWidth&lt;1030-60 or PianWidth&gt;1030+40)</l>
<l>    disp_message(hwnd, 'sidefun1 初步提取片区column1 error', 'window', (900)/h, 30, 'red', 'false')</l>
<l>    ret1 := -1</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>gen_rectangle1(RectangleAllPian, 0, PianColumn2-925, Height1-chipHeight/2, PianColumn2)</l>
<l>reduce_domain(Image, RectangleAllPian, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, 0, 150)</l>
<l>fill_up(Regions, RegionFillUp3)</l>
<l>opening_rectangle1(RegionFillUp3, RegionOpening, 50, 10)</l>
<l>fill_up(RegionOpening, RegionFillUp)</l>
<l>closing_rectangle1(RegionOpening, RegionClosing, 50, 10)</l>
<l>opening_rectangle1(RegionClosing, RegionOpening1, 500, 10)</l>
<l>connection(RegionOpening1, ConnectedRegions)</l>
<c></c>
<l>select_shape (ConnectedRegions, SelectedRegions, 'area', 'and', 40093.5, 99345.8)</l>
<l>count_obj(SelectedRegions, Number)</l>
<l>if(Number&lt;23)</l>
<l>    disp_message(hwnd, 'sidefun1 提取槽区域数量 &lt;23', 'window', (900)/h, 30, 'red', 'false')</l>
<l>    ret1 := -2</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>caoHeight :=0</l>
<l>caoHeightsTuple:=[0]</l>
<l>for Index := 1 to 23 by 1</l>
<l>    select_obj(SelectedRegions, ObjectSelected, Index)</l>
<l>    area_center(ObjectSelected, Area, Row, Column)</l>
<l>    if(Index!=1)</l>
<l>        if(Row-caoHeight&gt;chipHeight*1.5 or Row-caoHeight&lt;chipHeight*0.7)</l>
<l>            disp_message(hwnd, 'sidefun1 槽不连续', 'window', (900)/h, 30, 'red', 'true')</l>
<l>            ret1 := -3</l>
<l>            return()</l>
<l>        endif</l>
<l>    endif</l>
<l>    caoHeight := Row</l>
<l>    gen_contour_region_xld (ObjectSelected, Contours, 'border')</l>
<l>    fit_rectangle2_contour_xld (Contours, 'regression', -1, 0, 0, 3, 2, Row1, Column1, Phi, Length1, Length2, PointOrder)</l>
<l>    gen_rectangle2(Rectangle1, Row1, Column1, Phi, Length1, Length2)</l>
<c>    *传出拟合的槽区供下一函数使用</c>
<l>    concat_obj(outEmptyRegion, Rectangle1, outEmptyRegion)</l>
<l>    dilation_rectangle1(ObjectSelected, RegionDilation1, 0.5, 60)</l>
<l>    reduce_domain(Image, RegionDilation1, ImageReduced4)</l>
<l>    threshold (ImageReduced4, Regions4, 0, 120)</l>
<l>    closing_rectangle1(Regions4, RegionClosing3, 20, 1)</l>
<l>    fill_up(RegionClosing3, RegionFillUp2)</l>
<l>    opening_rectangle1(RegionFillUp2, RegionOpening4, 20, 3)</l>
<l>    connection(RegionOpening4, ConnectedRegions1)</l>
<l>    select_shape_std(ConnectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<l>    fill_up(SelectedRegions1, RegionFillUp1)</l>
<l>    opening_rectangle1(RegionFillUp1, RegionOpening2, 100, 1)</l>
<l>    erosion_rectangle1(RegionOpening2, RegionErosion, 1, 25)</l>
<l>    partition_rectangle (RegionErosion, Partitioned, 20, 200)</l>
<l>    region_features(Partitioned, 'height', caoHeightValues)</l>
<l>    tuple_max(caoHeightValues, caoHeightValuesMax)</l>
<l>    tuple_min(caoHeightValues, caoHeightValuesMin)</l>
<l>    tuple_mean(caoHeightValues, caoHeightValuesMean)</l>
<c>    *对宽度缩放,边缘不反光</c>
<l>    addoffset:=0</l>
<l>    caoHeightValuesMax_mm:=(caoHeightValuesMax-addoffset)*0.00982</l>
<l>    caoHeightValuesMin_mm:=(caoHeightValuesMin-addoffset)*0.00982</l>
<l>    caoHeightValuesMean_mm:=(caoHeightValuesMean-addoffset)*0.00982</l>
<c>    </c>
<c>    </c>
<l>    len1Value:=caoHeightValuesMean_mm</l>
<c></c>
<c>    *判断宽度</c>
<l>    len1Valuesz  := len1Value$'.2'</l>
<l>    if(len1Value&lt;CaoWidthMin or len1Value&gt;CaoWidthMax)</l>
<c>        *在槽宽大时，当上下边缘有白色亮点时可能是误判</c>
<l>        disp_message(hwnd, Index-1+' 槽宽：'+len1Valuesz+'mm', 'window', (Row+60)/h, (Column)/w, 'red', 'true')</l>
<l>        concat_obj(EmptyRegion, Rectangle1, EmptyRegion)</l>
<l>    elseif(1)</l>
<l>        disp_message(hwnd, Index-1+' 槽宽：'+len1Valuesz+'mm', 'window', (Row+60)/h, (Column)/w, 'blue', 'true')</l>
<l>        dev_display(Rectangle1)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1(outEmptyRegion, outRegion1)</l>
<c></c>
<c></c>
<c></c>
<l>union1(EmptyRegion, region1)</l>
<l>region_features(region1, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret1==0)</l>
<l>    ret1 := -10</l>
<l>endif</l>
<c></c>
<l>dev_set_color('red')</l>
<l>dev_display(region1)</l>
<c>*hv_hwnd</c>
<l>return ()</l>
</body>
<docu id="Sidefun1">
<parameters>
<parameter id="CaoWidthMax"/>
<parameter id="CaoWidthMin"/>
<parameter id="Image"/>
<parameter id="hwnd"/>
<parameter id="outRegion1"/>
<parameter id="region1"/>
<parameter id="ret1"/>
</parameters>
</docu>
</procedure>
<procedure name="Sidefun2">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="inRegion2" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region2" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="YiWuArea" base_type="ctrl" dimension="0"/>
<par name="YiWuHeight" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret2" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>ret2:=0</l>
<l>dev_set_color('green')</l>
<l>heightThreshold := YiWuHeight/0.00833-10</l>
<c></c>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<l>if(99&lt;11)</l>
<l>    disp_message(hwnd, 'sidefun2 提取槽区域数量 &lt;11', 'window', (1000)/h, 30, 'red', 'true')</l>
<l>    ret2 := -1</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>region_features(inRegion2, 'column2', inRegion2Column2)</l>
<l>gen_rectangle1(RectangleLeft, 0, inRegion2Column2-900, Height1, inRegion2Column2-760)</l>
<c></c>
<l>gen_rectangle1(RectangleMiddle, 0, inRegion2Column2-780, Height1, inRegion2Column2-220)</l>
<c></c>
<l>gen_rectangle1(RectangleRight, 0, inRegion2Column2-240, Height1, inRegion2Column2-10)</l>
<c></c>
<c>*找到槽顶部斜坡处过渡区</c>
<l>reduce_domain(Image, RectangleLeft, ImageReducedLeft)</l>
<l>threshold (ImageReducedLeft, RegionsBlackLeft, 0, 25)</l>
<l>connection(RegionsBlackLeft, ConnectedRegions4)</l>
<l>select_shape (ConnectedRegions4, SelectedRegions2, 'area', 'and', 3125.88, 50000)</l>
<l>fill_up(SelectedRegions2, RegionFillUp)</l>
<l>opening_circle(RegionFillUp, RegionOpening1, 10)</l>
<l>region_features(RegionOpening1, 'column2', Value)</l>
<l>tuple_mean(Value, LeftGuoDuColumn)</l>
<l>gen_rectangle1(RectangleLeft_L, 0, inRegion2Column2-900, Height1, LeftGuoDuColumn)</l>
<l>gen_rectangle1(RectangleLeft_R, 0, inRegion2Column2-810, Height1, inRegion2Column2-760)</l>
<c></c>
<l>connection(inRegion2, ConnectedRegions)</l>
<c></c>
<l>debugMark:=0</l>
<c></c>
<l>caoMidGrayValues:=[]</l>
<c></c>
<l>for Index := 1 to 22 by 1</l>
<l>    select_obj(ConnectedRegions, ObjectSelected, Index)</l>
<l>    region_features(ObjectSelected, 'column1', ObjectSelectedcolumn1)</l>
<l>    dilation_rectangle1(ObjectSelected, RegionDilation, 0.5, 20)</l>
<l>    reduce_domain(Image, RegionDilation, ImageReduced2)</l>
<l>    erosion_rectangle1(ObjectSelected, ObjectSelected_, 1, 25)</l>
<c>    *槽最左侧堵槽处缺料</c>
<l>    region_features(ObjectSelected_, ['column1','row1','row2'], ObjectSelected_Infos)</l>
<l>    gen_rectangle1(_RectangleLeft, ObjectSelected_Infos[1], ObjectSelected_Infos[0]-70, \
                   ObjectSelected_Infos[2], ObjectSelected_Infos[0])</l>
<l>    intensity(_RectangleLeft, Image, _RectangleLeftMean, Deviation2)</l>
<l>    if(_RectangleLeftMean&lt;40 or _RectangleLeftMean&gt;150)</l>
<l>        if(debugMark==1)</l>
<l>            dev_display(Image)</l>
<l>            dev_display(_RectangleLeft)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, _RectangleLeft, EmptyRegion)</l>
<l>    endif</l>
<c>    </c>
<c>    *左段异物检测</c>
<l>    intersection(ObjectSelected_, RectangleLeft, RegionLeft)</l>
<l>    erosion_rectangle1(RegionLeft, RegionErosionL, 1, 5)</l>
<c>      *左侧区域有白区</c>
<l>    intersection(RegionErosionL, RectangleLeft_L, _RegionIntersection_L)</l>
<l>    reduce_domain(Image, _RegionIntersection_L, ImageReducedL)</l>
<l>    intensity(_RegionIntersection_L, ImageReducedL, MeanLL, DeviationLL)</l>
<l>    if(MeanLL&gt;30)//</l>
<l>        if(debugMark==1)</l>
<l>            dev_display(Image)</l>
<l>            dev_display(_RegionIntersection_L)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, _RegionIntersection_L, EmptyRegion)</l>
<l>    endif</l>
<l>    threshold (ImageReducedL, RegionsLLight, 60, 255)//</l>
<l>    region_features(RegionsLLight, 'area', RegionsLLLightArea)</l>
<l>    if(RegionsLLLightArea&gt;500)//槽顶部斜坡处有沾料</l>
<l>        if(debugMark==1)</l>
<l>            dev_display(Image)</l>
<l>            dev_display(RegionsLLight)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, RegionsLLight, EmptyRegion)</l>
<l>    endif</l>
<c>      *右侧区域有黑区</c>
<l>    intersection(RegionErosionL, RectangleLeft_R, _RegionIntersection_R)</l>
<l>    reduce_domain(Image, _RegionIntersection_R, ImageReducedR)</l>
<l>    intensity(_RegionIntersection_R, ImageReducedR, _RegionIntersection_RMean, Deviation3)</l>
<c>    </c>
<l>    if(_RegionIntersection_RMean&lt;=30)</l>
<l>        disp_message(hwnd, 'sidefun2 槽左段右侧灰度低', 'window', (1000)/h, 30, 'red', 'true')</l>
<l>        if(debugMark==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, _RegionIntersection_R, EmptyRegion)</l>
<l>        _RegionIntersection_RMean:=30</l>
<l>    endif</l>
<c>    </c>
<l>    threshold (ImageReducedR, RegionsLBlack, 0, 35)//_RegionIntersection_RMean-30</l>
<l>    connection(RegionsLBlack, RegionsLBlackConnected)</l>
<l>    select_shape (RegionsLBlackConnected, SelectedRegionsLBlack, ['height','area'], 'and',\
                  [YiWuHeight,57.8], [200,10000])</l>
<l>    union1(SelectedRegionsLBlack, SelectedRegionsLBlackU1)</l>
<l>    region_features(SelectedRegionsLBlackU1, 'area', SelectedRegionsLBlackarea)</l>
<l>    if(SelectedRegionsLBlackarea&gt;400)//过渡区黑区域面积</l>
<c>        *在本区域靠左侧边缘，可能是斜坡区的延伸，在面积和宽度较小时排除</c>
<l>        region_features(_RegionIntersection_R, ['column1','width'], _RegionIntersection_RC1W)</l>
<l>        region_features(SelectedRegionsLBlackU1, ['column1','width'], SelectedRegionsLBlackU1C1W)</l>
<l>        if(_RegionIntersection_RC1W[0]==SelectedRegionsLBlackU1C1W[0] and\
           _RegionIntersection_RC1W[1]&gt;SelectedRegionsLBlackU1C1W[1]+10 and\
            SelectedRegionsLBlackarea&lt;600)</l>
<c>            *确定该区域右边区域是否有亮区，有则为异物，无则为斜坡区的延伸</c>
<l>            move_region(_RegionIntersection_R, RegionMoved, 0, -20)</l>
<l>            difference(RegionMoved, _RegionIntersection_R, RegionDifference)</l>
<l>            reduce_domain(Image, RegionDifference, ImageReduced1)</l>
<l>            threshold (ImageReduced1, Regions1, 50, 255)</l>
<l>            region_features(Regions1, 'area', Value3)</l>
<l>            if(Value3&gt;500)</l>
<l>                if(debugMark==1)</l>
<l>                    dev_display(Image)</l>
<l>                    dev_display(SelectedRegionsLBlackU1)</l>
<l>                    stop()</l>
<l>                endif</l>
<l>                concat_obj(EmptyRegion, SelectedRegionsLBlackU1, EmptyRegion)</l>
<l>            endif</l>
<l>        else</l>
<l>            if(debugMark==1)</l>
<l>                dev_display(Image)</l>
<l>                dev_display(SelectedRegionsLBlackU1)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            concat_obj(EmptyRegion, SelectedRegionsLBlackU1, EmptyRegion)</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    *中间段异物检测</c>
<l>    intersection(ObjectSelected_, RectangleMiddle, _RegionMiddle)</l>
<l>    reduce_domain(Image, _RegionMiddle, ImageReduced)</l>
<l>    intensity(_RegionMiddle, ImageReduced, Mean, Deviation)</l>
<l>    caoMidGrayValues:=[caoMidGrayValues,Mean]</l>
<l>    if(Mean&lt;=40)</l>
<l>        disp_message(hwnd, 'sidefun2 槽中段灰度低', 'window', (1000)/h, 30, 'red', 'true')</l>
<l>        if(debugMark==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, _RegionMiddle, EmptyRegion)</l>
<l>        Mean:=40</l>
<l>    endif</l>
<l>    threshold (ImageReduced, Regions, 0, Mean-40)//</l>
<l>    connection(Regions, ConnectedRegions1)</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions3, 'area', 'and', 15, 50000)</l>
<l>    union1(SelectedRegions3, RegionUnion)</l>
<l>    closing_circle(RegionUnion, RegionClosing1, 3.5)</l>
<l>    connection(RegionClosing1, ConnectedRegions5)</l>
<l>    select_shape (ConnectedRegions5, SelectedRegions, 'height', 'and', YiWuHeight, 200)</l>
<c>        *部分槽内电木粉灰度和无电木粉相同，只有条黑色边缘情况的下的提取</c>
<c>        *灰度不够低但高度很高</c>
<l>    threshold (ImageReduced, Regions, 0, Mean-30)//</l>
<c>       *提取高亮区域</c>
<l>    threshold (ImageReduced, Regions_, 200, 255)//</l>
<l>    connection(Regions_, ConnectedRegions2)</l>
<l>    select_shape_std(ConnectedRegions2, SelectedRegionsLight, 'max_area', 70)</l>
<l>    region_features(SelectedRegionsLight, 'area', LightArea)</l>
<l>    if(LightArea&gt;80)</l>
<l>        dilation_circle(SelectedRegionsLight, RegionDilation2, 10)</l>
<l>        union2(Regions, RegionDilation2, Regions)</l>
<l>    endif</l>
<c>    </c>
<l>    connection(Regions, ConnectedRegions1)</l>
<l>    select_shape (ConnectedRegions1, SelectedRegions3, 'area', 'and', 15, 50000)</l>
<l>    union1(SelectedRegions3, RegionUnion)</l>
<l>    closing_rectangle1(RegionUnion, RegionClosing2, 2, 5)</l>
<l>    connection(RegionClosing2, ConnectedRegions5_)</l>
<l>    region_features(_RegionMiddle, 'height', _RegionMiddleH)</l>
<l>    select_shape (ConnectedRegions5_, SelectedRegions_, 'height', 'and', _RegionMiddleH-5, 200)</l>
<l>    concat_obj(SelectedRegions, SelectedRegions_, SelectedRegions)</l>
<c>    </c>
<l>    count_obj(SelectedRegions, Number)</l>
<l>    for Index1 := 1 to Number by 1</l>
<l>        select_obj(SelectedRegions, ObjectSelected1, Index1)</l>
<l>        region_features(ObjectSelected1, 'width', ObjectSelected1W)</l>
<l>        region_features(ObjectSelected1, 'height', ObjectSelected1Height)</l>
<l>        region_features(ObjectSelected1, 'area', ObjectSelected1Area)</l>
<l>        region_features(ObjectSelected1, 'inner_radius', ObjectSelected1IR)</l>
<c>        *宽度大时，除去边缘的影响</c>
<l>        if(ObjectSelected1W&gt;40 and ObjectSelected1IR&gt;8)</l>
<l>            opening_circle(ObjectSelected1, ObjectSelected1Opened, 2)</l>
<l>            connection(ObjectSelected1Opened, ConnectedRegions3)</l>
<l>            region_features(ConnectedRegions3, 'height', ConnectedRegions3H)</l>
<l>            tuple_max(ConnectedRegions3H, Max1)</l>
<l>            select_shape (ConnectedRegions3, ObjectSelected1, 'height', 'and', Max1-1, 150)</l>
<l>        endif</l>
<c>        *如果区域高度值大，排除阈值升高</c>
<l>        addthreshold:=0</l>
<l>        if(ObjectSelected1Height&gt;40)</l>
<l>            addthreshold:=15</l>
<l>            if(ObjectSelected1IR&gt;8)</l>
<l>                addthreshold:=8</l>
<l>            endif</l>
<l>        endif</l>
<l>        if(Mean&gt;90)</l>
<l>            addthreshold:=addthreshold+Mean-90</l>
<l>        endif</l>
<l>        if( ObjectSelected1Area&gt;YiWuArea or ObjectSelected1Height&gt;YiWuHeight)</l>
<l>            reduce_domain(ImageReduced, ObjectSelected1, ImageReduced5)</l>
<c>            </c>
<l>            threshold (ImageReduced5, Regions4, 0, 20+addthreshold)//</l>
<l>            region_features(Regions4, 'area', Value1)</l>
<l>            if(Value1&lt;150)</l>
<l>                continue</l>
<l>            endif</l>
<l>            connection(Regions4, ConnectedRegions6)</l>
<l>            region_features(ConnectedRegions6, 'area', Value2)</l>
<l>            tuple_max(Value2, Max)</l>
<l>            if(Max&lt;40)</l>
<l>                continue</l>
<l>            endif</l>
<l>            if(debugMark==1)</l>
<l>                dev_display(Image)</l>
<l>                dev_display(ObjectSelected1)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            concat_obj(EmptyRegion, ObjectSelected1, EmptyRegion)</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<c>    *右段异物检测</c>
<l>    intersection(ObjectSelected_, RectangleRight, RegionRight_)</l>
<l>    reduce_domain(Image, RegionRight_, ImageReduced3)</l>
<l>    intensity(RegionRight_, ImageReduced3, Mean1, Deviation1)</l>
<l>    thresholdSUBValues:=40</l>
<l>    if(Mean1&lt;=40)</l>
<l>        if(Mean1&gt;30 and Deviation1&lt;18)//右段部分有均匀黑区，无异物情况，排除</l>
<l>            dev_display(RegionRight_)</l>
<l>            thresholdSUBValues:=25</l>
<l>        else</l>
<l>            disp_message(hwnd, 'sidefun2 槽右段灰度低', 'window', (1000)/h, 30, 'red', 'true')</l>
<l>            if(debugMark==1)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            concat_obj(EmptyRegion, RegionRight_, EmptyRegion)</l>
<l>            Mean1:=40</l>
<l>        endif</l>
<l>    elseif(Mean1&gt;Mean+3)</l>
<l>        if(Deviation1&gt;20)</l>
<c>            *槽右段灰度大于中断且偏差大时，可能有电木粉，提高提取阈值便于完全提取边缘黑区</c>
<l>            thresholdSUBValues:=30</l>
<l>        endif</l>
<l>    endif</l>
<l>    if(Deviation1&gt;20)//当偏差较大时，升高提取阈值,防止漏判</l>
<l>        dev_display(RegionRight_)</l>
<l>        thresholdSUBValues:=thresholdSUBValues-5</l>
<l>        if(Mean1&lt;55)</l>
<l>            thresholdSUBValues:=thresholdSUBValues-5</l>
<l>        endif</l>
<l>    endif</l>
<l>    threshold (ImageReduced3, Regions2, 0, Mean1-thresholdSUBValues)</l>
<c>       *提取高亮区域</c>
<l>    threshold (ImageReduced3, Regions_, 200, 255)//</l>
<l>    connection(Regions_, ConnectedRegions2)</l>
<l>    select_shape_std(ConnectedRegions2, SelectedRegionsLight, 'max_area', 70)</l>
<l>    region_features(SelectedRegionsLight, 'area', LightArea)</l>
<l>    if(LightArea&gt;80)</l>
<l>        dilation_circle(SelectedRegionsLight, RegionDilation2, 10)</l>
<l>        union2(Regions2, RegionDilation2, Regions2)</l>
<l>    endif</l>
<c>    </c>
<l>    connection(Regions2, ConnectedRegions7)</l>
<l>    select_shape (ConnectedRegions7, SelectedRegions4, 'area', 'and', 15, 20000)</l>
<l>    union1(SelectedRegions4, RegionUnion1)</l>
<l>    closing_circle(RegionUnion1, RegionClosing3, 3.5)</l>
<l>    connection(RegionClosing3, ConnectedRegions2)</l>
<l>    select_shape (ConnectedRegions2, SelectedRegions1, 'height', 'and', YiWuHeight, 200)</l>
<l>    count_obj(SelectedRegions1, Number)</l>
<l>    for Index1 := 1 to Number by 1</l>
<l>        select_obj(SelectedRegions1, ObjectSelected2, Index1)</l>
<l>        region_features(ObjectSelected2, 'area', ObjectSelected2Area)</l>
<l>        region_features(ObjectSelected2, 'height', ObjectSelected2Height)</l>
<l>        addthreshold:=0</l>
<l>        if(ObjectSelected2Height&gt;40)</l>
<l>            addthreshold:=10</l>
<l>        endif</l>
<l>        if(ObjectSelected2Area&gt;YiWuArea or ObjectSelected2Height&gt;YiWuHeight)</l>
<l>            reduce_domain(ImageReduced3, ObjectSelected2, ImageReduced4)</l>
<l>            threshold (ImageReduced4, Regions3, 0, 20+addthreshold)//</l>
<l>            region_features(Regions3, 'area', Value1)</l>
<l>            if(Value1&lt;100)</l>
<l>                continue</l>
<l>            endif</l>
<l>            connection(Regions3, ConnectedRegions6)</l>
<l>            region_features(ConnectedRegions6, 'area', Value2)</l>
<l>            tuple_max(Value2, Max)</l>
<l>            if(Max&lt;35)</l>
<l>                continue</l>
<l>            endif</l>
<l>            if(debugMark==1)</l>
<l>                dev_display(Image)</l>
<l>                dev_display(ObjectSelected2)</l>
<l>                stop()</l>
<l>            endif</l>
<l>            concat_obj(EmptyRegion, ObjectSelected2, EmptyRegion)</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c></c>
<l>tuple_mean(caoMidGrayValues, caoMidGrayValuesMean)</l>
<l>disp_message(hwnd, '槽灰度均值:'+caoMidGrayValuesMean, 'window', (1600)/h, 0, 'magenta', 'false')</l>
<l>disp_message(hwnd, '正常值范围:65~90', 'window', (1680)/h, 0, 'magenta', 'false')</l>
<l>union1(EmptyRegion, region2)</l>
<l>region_features(region2, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret2==0)</l>
<l>    ret2 := -10</l>
<l>    dev_set_color('red')</l>
<l>    dilation_rectangle1(region2, RegionDilation1, 30, 30)</l>
<l>    dev_display(RegionDilation1)</l>
<l>endif</l>
<c>*hv_hwnd</c>
<l>return ()</l>
<c></c>
</body>
<docu id="Sidefun2">
<parameters>
<parameter id="Image"/>
<parameter id="YiWuArea"/>
<parameter id="YiWuHeight"/>
<parameter id="hwnd"/>
<parameter id="inRegion2"/>
<parameter id="region2"/>
<parameter id="ret2"/>
</parameters>
</docu>
</procedure>
<procedure name="Sidefun3">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="inRegion3" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region3" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="blackArea" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret3" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>ret3:=0</l>
<l>dev_set_color('green')</l>
<c></c>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<l>if(99&lt;10)</l>
<l>    disp_message(hwnd, 'sidefun3 提取槽区域数量 &lt;10', 'window', (1100)/h, 30, 'red', 'true')</l>
<l>    ret3 := -1</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>pianWidths:=[]</l>
<c></c>
<l>connection(inRegion3, ConnectedRegions)</l>
<l>for Index := 1 to 22 by 1</l>
<l>    select_obj(ConnectedRegions, ObjectSelected, Index)</l>
<l>    select_obj(ConnectedRegions, ObjectSelected1, Index+1)</l>
<l>    union2(ObjectSelected, ObjectSelected1, RegionUnion)</l>
<l>    shape_trans(RegionUnion, RegionTrans, 'convex')</l>
<l>    difference(RegionTrans, RegionUnion, RegionDifference)</l>
<l>    opening_circle(RegionDifference, RegionOpening, 40)</l>
<c>    *求槽间距离，用于槽分度检测</c>
<l>    region_features(RegionOpening, 'rect2_len2', pianWidth)</l>
<l>    pianWidths:=[pianWidths,pianWidth*2]</l>
<c>    </c>
<l>    reduce_domain(Image, RegionOpening, ImageReduced2)</l>
<l>    threshold (ImageReduced2, Regions3, 110, 255)</l>
<l>    opening_circle(Regions3, RegionOpening1, 3.5)</l>
<l>    shape_trans(RegionOpening1, RegionTrans1, 'rectangle2')</l>
<c></c>
<l>    erosion_circle(RegionTrans1, RegionErosion, 6)</l>
<l>    move_region(RegionErosion, RegionMoved, 3, 0)</l>
<l>    reduce_domain(Image, RegionMoved, ImageReduced)</l>
<c>    *高阀值，提取生锈</c>
<l>    threshold (ImageReduced, Regions, 0, 120)</l>
<l>    region_features(Regions, 'area', Value)</l>
<c>    </c>
<c>    *低阀值，提取碰压、污渍</c>
<l>    threshold (ImageReduced, Regions2, 0, 85)</l>
<l>    connection(Regions2, ConnectedRegions1)</l>
<l>    select_shape_std(ConnectedRegions1, SelectedRegions, 'max_area', 70)</l>
<l>    region_features(SelectedRegions, ['area'], Maxarea)</l>
<l>    region_features(SelectedRegions, ['width'], Maxwidth)</l>
<l>    region_features(SelectedRegions, ['row','column'], Value1)</l>
<l>    region_features(RegionErosion, ['row1','row2','column2'], Value2)</l>
<c></c>
<c>    *</c>
<l>    if(Value&gt;blackArea or Maxarea&gt;blackArea/10)</l>
<c>        *消除上下边缘黑区造成的误判</c>
<l>        if(Maxarea&lt;700 and Maxwidth&gt;80)</l>
<l>            if(Value1[0]&lt;Value2[0]+10 or Value1[0]&gt;Value2[1]-10)</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c>        *消除底部小碰伤造成的误判</c>
<l>        if(Value1[1]&gt;Value2[2]-20 and Value&lt;blackArea+3000)</l>
<l>            reduce_domain(ImageReduced, SelectedRegions, ImageReduced1)</l>
<l>            threshold (ImageReduced1, Regions1, 0, 55)</l>
<l>            connection(Regions1, ConnectedRegions2)</l>
<l>            select_shape_std(ConnectedRegions2, SelectedRegions1, 'max_area', 70)</l>
<l>            region_features(SelectedRegions1, ['area','width'], Value3)</l>
<l>            if(Value3[0]&lt;400 and Value3[1]&lt;10)</l>
<l>                continue</l>
<l>            endif</l>
<l>        endif</l>
<c></c>
<c>        </c>
<l>        if(Maxarea&lt;500 and Value&lt;blackArea+10000)</l>
<l>            continue</l>
<l>        endif</l>
<c>        </c>
<l>        concat_obj(EmptyRegion, Regions, EmptyRegion)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>*在槽宽合格的条件下，槽分度检测</c>
<l>union1(EmptyRegion, region3)</l>
<l>region_features(region3, 'area', errorRgnArea)</l>
<l>pianwidthDifs:=[]</l>
<l>if(errorRgnArea==0 and ret3==0)</l>
<l>    for Index1 := 0 to 21 by 1</l>
<l>        pianwidthDif:=pianWidths[Index1]-pianWidths[(Index1+1)%22]</l>
<l>        pianwidthDifs:=[pianwidthDifs,pianwidthDif]</l>
<l>    endfor</l>
<l>    tuple_abs(pianwidthDifs, pianwidthDifs)</l>
<l>    tuple_max(pianwidthDifs, Max)</l>
<l>    tuple_find(pianwidthDifs, Max, Indices)</l>
<l>    if(Max&gt;50)</l>
<l>        disp_message(hwnd, 'sidefun3 槽分度异常', 'window', (1100)/h, 30, 'red', 'true')</l>
<l>        ret3 := -5</l>
<l>        select_obj(ConnectedRegions, ObjectSelectedCaoUp, Indices)</l>
<l>        select_obj(ConnectedRegions, ObjectSelectedCaoMid, Indices+1)</l>
<l>        select_obj(ConnectedRegions, ObjectSelectedCaoDown, Indices+2)</l>
<l>        union2(ObjectSelectedCaoUp, ObjectSelectedCaoDown, RegionUnionCaoThree)</l>
<l>        shape_trans(RegionUnionCaoThree, PianErrDouble, 'convex')</l>
<l>        dev_set_color('red')</l>
<l>        dev_display(PianErrDouble)</l>
<l>        return()</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>union1(EmptyRegion, region3)</l>
<l>region_features(region3, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret3==0)</l>
<l>    ret3 := -10</l>
<l>endif</l>
<c></c>
<l>dev_set_color('red')</l>
<l>dev_display(region3)</l>
<c>*hv_hwnd</c>
<l>return ()</l>
<c></c>
</body>
<docu id="Sidefun3">
<parameters>
<parameter id="Image"/>
<parameter id="blackArea"/>
<parameter id="hwnd"/>
<parameter id="inRegion3"/>
<parameter id="region3"/>
<parameter id="ret3"/>
</parameters>
</docu>
</procedure>
<procedure name="funReserve0">
<interface/>
<body>
<c></c>
</body>
<docu id="funReserve0">
<parameters/>
</docu>
</procedure>
<procedure name="Sidefun4">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="inRegion4" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region4" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="input_Scale_1Goupian" base_type="ctrl" dimension="0"/>
<par name="hwnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret4" base_type="ctrl" dimension="0"/>
<par name="ret5" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<l>ret4:=0</l>
<l>ret5:=0</l>
<l>dev_set_color('green')</l>
<c></c>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<c>*2019-09-18改 由于片的上（左）边缘提取不稳定（上边缘形状不稳定），利用下边缘来作为钩区域定位参照</c>
<l>region_features(inRegion4,'column2', ChipColumn2)</l>
<l>gouMin := ChipColumn2-1050</l>
<l>gouMax := ChipColumn2-1050+90</l>
<l>gen_rectangle1(RectangleSTD, 0, gouMin, Height1, gouMax)</l>
<l>gouMiddle :=ChipColumn2-970</l>
<l>gen_region_line(RegionLinesSTD, 0, gouMiddle, Height1, gouMiddle)</l>
<l>dev_display(RegionLinesSTD)</l>
<c></c>
<l>move_region(inRegion4, inRegion4Moved, 0, -150)</l>
<l>connection(inRegion4Moved, inRegion4ConnectedRegions)</l>
<c></c>
<l>gen_empty_region(GouDing)</l>
<l>gouPianDif:=[]</l>
<c></c>
<c></c>
<l>for Index0 := 1 to 22 by 1</l>
<l>    select_obj(inRegion4ConnectedRegions, caoUp, Index0)</l>
<l>    select_obj(inRegion4ConnectedRegions, caoDown, Index0+1)</l>
<l>    union2(caoUp, caoDown, caoUpDownRegionUnion)</l>
<l>    closing_rectangle1(caoUpDownRegionUnion, RegionClosing2, 2, 300)</l>
<l>    difference(RegionClosing2, caoUpDownRegionUnion, RegionDifference)</l>
<l>    intersection(RegionDifference, RectangleSTD, RegionIntersectionSTD)</l>
<l>    region_features(RegionIntersectionSTD, ['row'], chipValueSTD)</l>
<c>    </c>
<c>    *钩顶区域提取</c>
<l>    gen_empty_region(gouDingSingle)</l>
<l>    gen_empty_region(gouDingSingleFirst)</l>
<l>    erosion_rectangle1(RegionIntersectionSTD, RegionErosion, 0.5, 140)</l>
<l>    reduce_domain(Image, RegionErosion, ImageReduced6)</l>
<c>    </c>
<l>    gen_empty_region(RegionIntersection1)</l>
<l>    MaxHlast:=0</l>
<l>    heightUplimit:=100</l>
<l>    for thresholdNum46 := 60 to 140 by 10</l>
<l>        threshold (ImageReduced6, Regions, 0, thresholdNum46)//</l>
<l>        opening_circle(Regions, RegionOpening, 3)</l>
<l>        connection(RegionOpening, ConnectedRegions4)</l>
<l>        region_features(ConnectedRegions4, 'height', Value1)</l>
<l>        tuple_max(Value1, MaxH)</l>
<c>        </c>
<l>        if(MaxH&gt;=heightUplimit and MaxHlast&lt;=75)</l>
<l>            threshold (ImageReduced6, Regions, 0, thresholdNum46-5)//</l>
<l>            opening_circle(Regions, RegionOpening, 5)</l>
<l>            connection(RegionOpening, ConnectedRegions4)</l>
<l>            region_features(ConnectedRegions4, 'height', Value1)</l>
<l>            tuple_max(Value1, MaxH)</l>
<l>            if(MaxH&gt;=heightUplimit and MaxH&lt;=108)</l>
<l>                heightUplimit:=108</l>
<l>            endif</l>
<l>        endif</l>
<l>        MaxHlast:=MaxH</l>
<l>        if(MaxH&lt;heightUplimit and MaxH&gt;75)</l>
<l>            tuple_find(Value1,MaxH,  Indices)</l>
<l>            select_obj(ConnectedRegions4, SelectedMax, Indices+1)</l>
<l>            region_features(SelectedMax, ['row1','row2'], SelectedMaxInfos)</l>
<l>            gen_rectangle1(Rectangle, SelectedMaxInfos[0],gouMin,  SelectedMaxInfos[1] ,gouMax)</l>
<l>            intersection(Rectangle, Regions, RegionIntersection1)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>    closing_rectangle1(RegionIntersection1, Regions_, 2, 30)</l>
<l>    opening_rectangle1(Regions_, RegionOpening2, 5, 20)</l>
<l>    region_features(RegionOpening2, 'height', Value)</l>
<c>    </c>
<l>    connection(RegionOpening2, ConnectedRegions2)</l>
<l>    select_shape (ConnectedRegions2, SelectedRegions, 'height', 'and', 60.459, 200)</l>
<l>    count_obj(SelectedRegions, Number2)</l>
<l>    if(Number2==0)</l>
<l>        disp_message(hwnd, 'sidefun4 钩顶区无钩', 'window', (1200)/h, 30, 'red', 'true')</l>
<l>        ret4 := -1</l>
<l>        *concat_obj(RegionErosion, EmptyRegion, EmptyRegion)</l>
<l>        dev_set_color('red')</l>
<l>        dev_display(RegionErosion)</l>
<l>        return()</l>
<l>    endif</l>
<c>    *选最右边的一条区域</c>
<l>    if(Number2&gt;1)</l>
<l>        region_features(SelectedRegions, 'column2', SelectedRegionsC2)</l>
<l>        tuple_max(SelectedRegionsC2, MaxC2)</l>
<l>        select_shape (SelectedRegions, SelectedRegions, 'column2', 'and', MaxC2-1, MaxC2+1)</l>
<l>    endif</l>
<c>    </c>
<l>    region_features(SelectedRegions, ['area','height','width','inner_radius'], GouMaxInfos)</l>
<c>    *钩窄的情况下</c>
<l>    openRectW:=7</l>
<l>    opening_rectangle1(SelectedRegions, RegionOpening1, openRectW, 50)</l>
<l>    region_features(RegionOpening1, 'height', RegionOpening1Height)</l>
<l>    region_features(RegionOpening1, 'area', RegionOpening1Area)</l>
<l>    if(GouMaxInfos[1]-RegionOpening1Height &gt; 20 or RegionOpening1Area&lt;650)</l>
<l>        if(RegionOpening1Height==0)</l>
<l>            openRectW:=5</l>
<l>        endif</l>
<l>        shape_trans(SelectedRegions, SelectedRegions, 'rectangle1')</l>
<l>    endif</l>
<c>    </c>
<l>    for columnMovedDistance := 70 to -1 by -10</l>
<l>        move_region(RegionErosion, RegionMoved0, 0, columnMovedDistance)</l>
<l>        intersection(SelectedRegions, RegionMoved0, RegionIntersection)</l>
<l>        opening_rectangle1(RegionIntersection, RegionOpening1, openRectW, 50)</l>
<l>        region_features(RegionOpening1, 'height', RegionOpening1Height)</l>
<l>        if(RegionOpening1Height&gt;60 and RegionOpening1Height&lt;105)</l>
<c>            *当有两条时合并</c>
<l>            connection(RegionOpening1, ConnectedRegions1)</l>
<l>            count_obj(ConnectedRegions1, Number1)</l>
<l>            if(Number1&gt;1)</l>
<l>                closing_rectangle1(RegionOpening1, RegionOpening1, 60, 1)</l>
<l>            endif</l>
<l>            union1(RegionOpening1, gouDingSingle)</l>
<l>            break</l>
<l>        endif</l>
<l>    endfor</l>
<c></c>
<c>    </c>
<l>    region_features(gouDingSingle, ['area'], SingleGouDingArea)</l>
<l>    if(SingleGouDingArea[0]==0)</l>
<l>        disp_message(hwnd, 'sidefun4 钩顶区域未找到钩', 'window', (1200)/h, 30, 'red', 'true')</l>
<l>        ret4 := -2</l>
<l>        *concat_obj(RegionErosion, EmptyRegion, EmptyRegion)</l>
<l>        dev_set_color('red')</l>
<l>        dev_display(RegionErosion)</l>
<l>        return()</l>
<l>    else</l>
<l>        dev_display(gouDingSingle)</l>
<l>        concat_obj(GouDing, gouDingSingle, GouDing)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1(GouDing, RegionUnion)</l>
<l>connection(RegionUnion, ConnectedRegions)</l>
<l>count_obj(ConnectedRegions, Number)</l>
<l>if(Number!=22)</l>
<l>    disp_message(hwnd, 'sidefun4 提取钩顶区域数量 !=22', 'window', (1200)/h, 30, 'red', 'true')</l>
<l>    ret4 := -4</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<c>*钩高度判断</c>
<l>region_features(ConnectedRegions, 'column2', GouDingColumn2Values)</l>
<l>tuple_sub(ChipColumn2, GouDingColumn2Values, GouHeightsValues)</l>
<l>tuple_mean(GouHeightsValues, Mean)</l>
<l>if(Mean&gt;1020 or Mean&lt;970)</l>
<l>    disp_message(hwnd, 'sidefun4 钩高度均值异常', 'window', (1200)/h, 30, 'red', 'true')</l>
<l>    ret4 := -3</l>
<l>    *concat_obj(RegionErosion, EmptyRegion, EmptyRegion)</l>
<l>    dev_set_color('red')</l>
<l>    dev_display(GouDing)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>isdebug:= 0</l>
<c></c>
<l>for Index := 0 to 21 by 1</l>
<l>    tuple_select(GouHeightsValues, Index, Selected)</l>
<c>    *判断</c>
<l>    if(Selected&gt;Mean+input_Scale_1Goupian+5)//钩高</l>
<l>        if(isdebug==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        select_obj(ConnectedRegions, ObjectSelected, Index+1)</l>
<l>        concat_obj(ObjectSelected, EmptyRegion, EmptyRegion)</l>
<l>    elseif(Selected&lt;Mean-input_Scale_1Goupian-5)//钩低</l>
<l>        if(isdebug==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        select_obj(ConnectedRegions, ObjectSelected, Index+1)</l>
<l>        concat_obj(ObjectSelected, EmptyRegion, EmptyRegion)</l>
<l>    endif</l>
<c>    </c>
<l>    tuple_select(GouHeightsValues, (Index+1)%22, Selected1)</l>
<l>    difNum:=Selected1-Selected</l>
<c>    *当前钩比下一钩低35+，可能是下一钩顶区域有高灰度，导致提取错误，矫正。</c>
<l>    if(difNum&gt;35)</l>
<l>        select_obj(ConnectedRegions, ObjectSelectedNext, (Index+1)%22+1)</l>
<l>        move_region(ObjectSelectedNext, RegionMoved, 0, difNum)</l>
<l>        dilation_circle(RegionMoved, RegionDilation, 7)</l>
<l>        reduce_domain(Image, RegionDilation, ImageReduced)</l>
<l>        threshold (ImageReduced, Regions1, 0, thresholdNum46+50)//高阈值</l>
<l>        closing_rectangle1(Regions1, RegionClosing, 1, 10)</l>
<l>        opening_rectangle1(RegionClosing, RegionOpening3, 7, 50)</l>
<l>        region_features(RegionOpening3, ['area','height','column2'], CorrectGouInfos)</l>
<l>        if(CorrectGouInfos[0]&gt;800 and CorrectGouInfos[1]&gt;70)</l>
<l>            dev_set_color('magenta')</l>
<l>            dev_display(RegionOpening3)</l>
<l>            concat_obj(GouDing, RegionOpening3, GouDing)</l>
<c>            </c>
<l>            nextGouHeight:=ChipColumn2-CorrectGouInfos[2]</l>
<l>            GouHeightsValues[(Index+1)%22]:=nextGouHeight</l>
<l>            difNum:=nextGouHeight-Selected</l>
<l>        endif</l>
<l>    endif</l>
<c>    </c>
<c>    </c>
<l>    tuple_abs(difNum, Abs)</l>
<l>    if(Abs&gt;input_Scale_1Goupian)//</l>
<l>        if(isdebug==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        select_obj(ConnectedRegions, ObjectSelected, Index+1)</l>
<l>        concat_obj(ObjectSelected, EmptyRegion, EmptyRegion)</l>
<l>        select_obj(ConnectedRegions, ObjectSelected, (Index+1)%22+1)</l>
<l>        concat_obj(ObjectSelected, EmptyRegion, EmptyRegion)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>union1(EmptyRegion, region4)</l>
<l>region_features(region4, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret4==0)</l>
<l>    ret4 := -10</l>
<l>endif</l>
<c></c>
<l>dev_set_color('red')</l>
<l>dev_display(region4)</l>
<c>*hv_hwnd</c>
<l>return ()</l>
<c></c>
</body>
<docu id="Sidefun4">
<parameters>
<parameter id="Image"/>
<parameter id="hwnd"/>
<parameter id="inRegion4"/>
<parameter id="input_Scale_1Goupian"/>
<parameter id="region4"/>
<parameter id="ret4"/>
<parameter id="ret5"/>
</parameters>
</docu>
</procedure>
<procedure name="funCorrectImage">
<interface>
<io>
<par name="image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="imageCorrected0" base_type="iconic" dimension="0"/>
<par name="imageCorrected1" base_type="iconic" dimension="0"/>
<par name="imageCorrected2" base_type="iconic" dimension="0"/>
</oo>
</interface>
<body>
<c></c>
<l>* copy_image (image, imageCorrected0)</l>
<l>* copy_image (image, imageCorrected1)</l>
<c></c>
<l>* return ()</l>
<c>*两张图片时的判断与修正</c>
<l>count_obj (image, Channels)</l>
<l>if(Channels==1)</l>
<l>    select_obj(image, Image1, 1)</l>
<l>elseif(Channels==2)</l>
<l>    select_obj(image, Image1, 1)</l>
<l>    select_obj(image, Image2, 2)</l>
<l>elseif(Channels==3)</l>
<l>    select_obj(image, Image1, 1)</l>
<l>    select_obj(image, Image2, 2)</l>
<l>    select_obj(image, Image3, 3)</l>
<l>endif</l>
<c></c>
<l>* threshold (Image1, Regions, 0, 150)</l>
<l>* opening_circle(Regions, RegionOpening, 3.5)</l>
<c></c>
<l>* closing_circle(RegionOpening, RegionClosing, 3.5)</l>
<l>* connection(RegionClosing, ConnectedRegions)</l>
<l>* fill_up(ConnectedRegions, RegionFillUp)</l>
<l>* select_shape_std(RegionFillUp, SelectedRegions1, 'max_area', 70)</l>
<l>* difference(RegionFillUp, SelectedRegions1, SelectedRegions)</l>
<l>* union1(SelectedRegions, RegionUnion)</l>
<l>* dilation_circle(RegionUnion, RegionDilation, 35)</l>
<c></c>
<l>* count_obj(RegionDilation, Number)</l>
<l>* if(Number==0)</l>
<l>*     gen_region_points(RegionDilation, 100, 100)</l>
<l>* endif</l>
<c></c>
<l>gen_ellipse (ROI_0, 1365.5, 1869.5, rad(-1.48018), 1548.52, 1378.95)</l>
<c></c>
<c></c>
<l>difference(Image1, ROI_0, RegionDilation)</l>
<c></c>
<c></c>
<c></c>
<l>if(Channels==1)</l>
<l>    paint_region (RegionDilation, Image1, imageCorrected0, 245, 'fill')</l>
<l>    copy_image(imageCorrected0, imageCorrected1)</l>
<l>elseif(Channels==2)</l>
<l>    paint_region (RegionDilation, Image1, imageCorrected0, 245, 'fill')</l>
<l>    paint_region (RegionDilation, Image2, imageCorrected1, 245, 'fill')</l>
<l>elseif(Channels==3)</l>
<l>    paint_region (RegionDilation, Image1, imageCorrected0, 245, 'fill')</l>
<l>    paint_region (RegionDilation, Image2, imageCorrected1, 245, 'fill')</l>
<l>    paint_region (RegionDilation, Image3, imageCorrected2, 245, 'fill')</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="funCorrectImage">
<parameters>
<parameter id="image"/>
<parameter id="imageCorrected0"/>
<parameter id="imageCorrected1"/>
<parameter id="imageCorrected2"/>
</parameters>
</docu>
</procedure>
<procedure name="Sidefun5">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
<par name="inRegion5" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region5" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="shoulderValue" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret5" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>ret5:=0</l>
<l>dev_set_color('green')</l>
<c></c>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<l>if(99&lt;18)</l>
<l>    disp_message(hwnd, 'sidefun3 提取槽区域数量 &lt;18', 'window', (1300)/h, 30, 'red', 'true')</l>
<l>    ret5 := -1</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>connection(inRegion5, ConnectedRegions)</l>
<l>for Index := 1 to 18 by 1</l>
<l>    select_obj(ConnectedRegions, ObjectSelected, Index)</l>
<l>    select_obj(ConnectedRegions, ObjectSelected1, Index+1)</l>
<l>    union2(ObjectSelected, ObjectSelected1, RegionUnion)</l>
<l>    shape_trans(RegionUnion, RegionTrans, 'convex')</l>
<l>    difference(RegionTrans, RegionUnion, RegionDifference)</l>
<l>    opening_circle(RegionDifference, RegionOpening, 5)</l>
<l>    connection(RegionOpening, ConnectedRegions2)</l>
<l>    select_shape_std(ConnectedRegions2, SelectedRegions, 'max_area', 70)</l>
<l>    move_region(SelectedRegions, RegionMoved, 0, -50)</l>
<l>    difference(RegionMoved, SelectedRegions, RegionDifference1)</l>
<l>    connection(RegionDifference1, ConnectedRegions1)</l>
<l>    select_shape_std(ConnectedRegions1, SelectedRegions1, 'max_area', 70)</l>
<c>    *片宽度不等，通过实际宽度腐蚀</c>
<l>    region_features(SelectedRegions1, 'height', Value1)</l>
<l>    erosionValue:=50+(Value1-250)</l>
<l>    *erosion_rectangle1(SelectedRegions1, SelectedRegions1, 0.5, 8)</l>
<l>    erosion_rectangle1(SelectedRegions1, RegionErosion, 0.5, erosionValue)</l>
<l>    difference(SelectedRegions1, RegionErosion, RegionDifference2)</l>
<l>    opening_circle(RegionDifference2, RegionOpening1, 2.5)</l>
<c>  </c>
<l>    xxxxx:=82</l>
<l>    gen_empty_region(shoulderRegion0)</l>
<l>    connection(RegionOpening1, ConnectedRegions3)</l>
<l>    select_shape (ConnectedRegions3, ConnectedRegions3, 'area', 'and', 1143.52, 5000)</l>
<l>    count_obj(ConnectedRegions3, Number)</l>
<l>    if(Number!=2)</l>
<l>        disp_message(hwnd, 'sidefun5 肩区数量！=2', 'window', (1300)/h, 30, 'red', 'true')</l>
<l>        ret5 := -2</l>
<l>        *stop()</l>
<l>        return()</l>
<l>    endif</l>
<l>    for Index1 := 1 to 2 by 1</l>
<l>        select_obj(ConnectedRegions3, ObjectSelected2, Index1)</l>
<l>        reduce_domain(Image, ObjectSelected2, ImageReduced)</l>
<c>        *获取片上面熟料区灰度值</c>
<l>        if(Index1==1)</l>
<l>            shape_trans(ObjectSelected, RegionTrans1, 'rectangle2')</l>
<l>            move_region(RegionTrans1, RegionMoved1, 0, -70)</l>
<l>            difference(RegionMoved1, RegionTrans1, RegionDifference3)</l>
<l>            opening_circle(RegionDifference3, RegionOpening3, 20)</l>
<l>            move_region(RegionOpening3, RegionMoved2, 40, -100)</l>
<l>            dilation_circle(RegionMoved2, RegionDilation, 5)</l>
<l>            intensity (RegionDilation, Image, Mean, Deviation)</l>
<l>        else</l>
<l>            shape_trans(ObjectSelected1, RegionTrans1, 'rectangle2')</l>
<l>            move_region(RegionTrans1, RegionMoved1, 0, -70)</l>
<l>            difference(RegionMoved1, RegionTrans1, RegionDifference3)</l>
<l>            opening_circle(RegionDifference3, RegionOpening3, 20)</l>
<l>            move_region(RegionOpening3, RegionMoved2, -40, -100)</l>
<l>            dilation_circle(RegionMoved2, RegionDilation, 20)</l>
<l>            intensity (RegionDilation, Image, Mean, Deviation)</l>
<l>        endif</l>
<l>        threshold (ImageReduced, Regions, 0, Mean+40)</l>
<l>        closing_rectangle1(Regions, Regions, 1, 25)</l>
<c>        *下值越大越精确</c>
<l>        judgeValue:=shoulderValue-(330-Value1)/2/2</l>
<l>        if(judgeValue&gt;50)</l>
<l>            judgeValue:=50</l>
<l>        endif</l>
<l>        if(judgeValue&lt;=1)</l>
<l>            judgeValue:=1</l>
<l>        endif</l>
<l>        opening_rectangle1(Regions, RegionOpening2, 10, judgeValue)</l>
<l>        region_features(RegionOpening2, 'area', Value)</l>
<l>        if(Value&lt;500)</l>
<l>*             dev_display(Regions)</l>
<l>*             stop()</l>
<l>            concat_obj(EmptyRegion, Regions, EmptyRegion)</l>
<l>        endif</l>
<l>    endfor</l>
<l>*    dev_clear_window()</l>
<l>*    dev_display(Image)</l>
<l>*    dev_display(RegionOpening1)</l>
<c>    </c>
<c>    </c>
<l>endfor</l>
<c></c>
<l>union1(EmptyRegion, region5)</l>
<l>region_features(region5, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret5==0)</l>
<l>    ret5 := -10</l>
<l>endif</l>
<c></c>
<l>dev_set_color('red')</l>
<l>dev_display(region5)</l>
<c>*hv_hwnd</c>
<l>return ()</l>
<c></c>
<c></c>
</body>
<docu id="Sidefun5">
<parameters>
<parameter id="Image"/>
<parameter id="hwnd"/>
<parameter id="inRegion5"/>
<parameter id="region5"/>
<parameter id="ret5"/>
<parameter id="shoulderValue"/>
</parameters>
</docu>
</procedure>
<procedure name="fun5">
<interface>
<io>
<par name="imageCorrected0" base_type="iconic" dimension="0"/>
<par name="imageCorrected1" base_type="iconic" dimension="0"/>
<par name="imageCorrected2" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="input_Scale_1" base_type="ctrl" dimension="0"/>
<par name="gouchangMin" base_type="ctrl" dimension="0"/>
<par name="gouchangMax" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret5" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<c></c>
<l>ret5 := 0</l>
<l>graythreshold:=160</l>
<l>areathreshold := 1500</l>
<l>diameterMax := 2800</l>
<l>diameterMin := 1365*2</l>
<l>areaoffset := 500000</l>
<l>tongPianRadRadius:=998//铜片构成的圆的大致半径</l>
<l>gouCount:=22//钩的数量</l>
<c></c>
<c></c>
<c></c>
<l>dev_set_color('blue')</l>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(imageCorrected0, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<c></c>
<c>*第一张图片</c>
<l>threshold (imageCorrected0, Regions, 0, graythreshold)</l>
<l>connection(Regions, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<c>*面积判断</c>
<l>region_features(SelectedRegions, 'area', areaValue)</l>
<l>calculatedArea:=3.14*tongPianRadRadius*tongPianRadRadius</l>
<l>if(areaValue&lt;calculatedArea-areaoffset or areaValue&gt;calculatedArea+areaoffset)</l>
<l>    disp_message(hwnd, 'topfun5 选择整体区域面积eorror', 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>    ret5 := -1</l>
<l>    return()</l>
<l>endif</l>
<l>fill_up(SelectedRegions, RegionFillUp)</l>
<l>reduce_domain(imageCorrected0, RegionFillUp, ImageReduced)</l>
<l>threshold (ImageReduced, Regions1, 100, 255)</l>
<l>connection(Regions1, ConnectedRegions1)</l>
<l>select_shape_std(ConnectedRegions1, SelectedRegions2, 'max_area', 70)</l>
<l>area_center(SelectedRegions2, Area, Row, Column)</l>
<c></c>
<l>gen_circle(Circle, Row, Column, tongPianRadRadius+27)</l>
<l>difference(SelectedRegions, Circle, RegionDifference)</l>
<l>gen_region_points(Region0, Row, Column)</l>
<c></c>
<l>opening_circle(RegionDifference, RegionOpening, 8)</l>
<l>connection(RegionOpening, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, ConnectedRegions2, 'area', 'and', 9000, 28000)</l>
<l>count_obj(ConnectedRegions2, Number)</l>
<l>circleTimes :=gouCount/2</l>
<l>if(Number!=gouCount)</l>
<l>    disp_message(hwnd, 'topfun5 提取钩部区域数量 ！='+gouCount, 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>    ret5 := -2</l>
<l>    if(Number%2=1)</l>
<l>        circleTimes := (Number+1)/2</l>
<l>    endif</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>gen_circle(CircleSTD0, Row, Column, tongPianRadRadius-2)</l>
<l>gen_circle(CircleSTD1, Row, Column, tongPianRadRadius+202)</l>
<c></c>
<l>*dev_display(CircleSTD1)</l>
<c></c>
<c></c>
<l>GouRadiusRight:=[]</l>
<l>GouRadiusLeft:=[]</l>
<l>gen_empty_region(gouRadiusLineRight)</l>
<l>gen_empty_region(gouRadiusLineLeft)</l>
<c></c>
<c></c>
<c></c>
<l>select_obj(ConnectedRegions2, ObjectSelected1, 1)</l>
<l>shape_trans(ObjectSelected1, RegionTrans, 'outer_circle')</l>
<l>dilation_circle(RegionTrans, circleMudle, 50)</l>
<c></c>
<l>for Index := 1 to circleTimes by 1</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -rad(360/22*(Index-1)), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(circleMudle, GouOuterCircle0, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(180), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(GouOuterCircle0, GouOuterCircle1, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    union2(GouOuterCircle0, GouOuterCircle1, GouOuterCircle)</l>
<l>    intersection(GouOuterCircle, ConnectedRegions2, TwoSymmetryGous)</l>
<l>    region_features(TwoSymmetryGous, 'area', TwoSymmetryGousArea)</l>
<l>    if(TwoSymmetryGousArea&lt;22000)</l>
<l>        disp_message(hwnd, 'topfun5 未找到对称区域', 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>        ret5 := -3</l>
<l>        return()</l>
<l>    endif</l>
<l>    shape_trans(TwoSymmetryGous, TwoSymmetryGousConvex, 'convex')</l>
<l>    opening_circle(TwoSymmetryGousConvex, TwoSymmetryGousOpened, 30)</l>
<l>    region_features(TwoSymmetryGousOpened, 'max_diameter', twoOutGouDiameter)</l>
<c></c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle0, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)</l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionRight)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineRight, RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionRight, 'max_diameter', Value1)</l>
<l>    GouRadiusRight:=[GouRadiusRight,Value1]</l>
<c>    </c>
<c>    </c>
<c>    *left-down</c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle1, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)    </l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionLeft)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineLeft, RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionLeft, 'max_diameter', Value1)</l>
<l>    GouRadiusLeft:=[GouRadiusLeft,Value1]</l>
<l>endfor</l>
<c></c>
<l>tuple_concat(GouRadiusRight, GouRadiusLeft, GouRadiusAll0)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*第2张图片</c>
<l>threshold (imageCorrected1, Regions, 0, graythreshold)</l>
<l>connection(Regions, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>fill_up(SelectedRegions, RegionFillUp)</l>
<l>erosion_circle(RegionFillUp, RegionErosion, 30)</l>
<l>gen_circle(Circle, Row, Column, tongPianRadRadius+27)</l>
<l>difference(SelectedRegions, Circle, RegionDifference)</l>
<l>opening_circle(RegionDifference, RegionOpening, 8)</l>
<l>connection(RegionOpening, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, ConnectedRegions2, 'area', 'and', 9000, 28000)</l>
<l>count_obj(ConnectedRegions2, Number)</l>
<l>circleTimes :=gouCount/2</l>
<l>if(Number!=gouCount)</l>
<l>    disp_message(hwnd, 'topfun5 提取钩部区域数量 ！='+gouCount, 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>    ret5 := -2</l>
<l>    if(Number%2=1)</l>
<l>        circleTimes := (Number+1)/2</l>
<l>    endif</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>GouRadiusRight:=[]</l>
<l>GouRadiusLeft:=[]</l>
<l>gen_empty_region(gouRadiusLineRight)</l>
<l>gen_empty_region(gouRadiusLineLeft)</l>
<c></c>
<l>select_obj(ConnectedRegions2, ObjectSelected1, 1)</l>
<l>shape_trans(ObjectSelected1, RegionTrans, 'outer_circle')</l>
<l>dilation_circle(RegionTrans, circleMudle, 50)</l>
<c></c>
<l>for Index := 1 to circleTimes by 1</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -rad(360/22*(Index-1)), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(circleMudle, GouOuterCircle0, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(180), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(GouOuterCircle0, GouOuterCircle1, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    union2(GouOuterCircle0, GouOuterCircle1, GouOuterCircle)</l>
<l>    intersection(GouOuterCircle, ConnectedRegions2, TwoSymmetryGous)</l>
<l>    region_features(TwoSymmetryGous, 'area', TwoSymmetryGousArea)</l>
<l>    if(TwoSymmetryGousArea&lt;22000)</l>
<l>        disp_message(hwnd, 'topfun5 未找到对称区域', 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>        ret5 := -3</l>
<l>        return()</l>
<l>    endif</l>
<l>    shape_trans(TwoSymmetryGous, TwoSymmetryGousConvex, 'convex')</l>
<l>    opening_circle(TwoSymmetryGousConvex, TwoSymmetryGousOpened, 30)</l>
<l>    region_features(TwoSymmetryGousOpened, 'max_diameter', twoOutGouDiameter)</l>
<c></c>
<c>    *半径线条及其长度</c>
<c>    *right-up</c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle0, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)</l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionRight)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineRight, RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionRight, 'max_diameter', Value1)</l>
<l>    GouRadiusRight:=[GouRadiusRight,Value1]</l>
<c>    </c>
<c>    </c>
<c>    *left-down</c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle1, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)    </l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionLeft)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineLeft, RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionLeft, 'max_diameter', Value1)</l>
<l>    GouRadiusLeft:=[GouRadiusLeft,Value1]</l>
<l>endfor</l>
<c></c>
<l>tuple_concat(GouRadiusRight, GouRadiusLeft, GouRadiusAll1)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c>*第3张图片</c>
<l>threshold (imageCorrected2, Regions, 0, graythreshold)</l>
<l>connection(Regions, ConnectedRegions)</l>
<l>select_shape_std(ConnectedRegions, SelectedRegions, 'max_area', 70)</l>
<l>fill_up(SelectedRegions, RegionFillUp)</l>
<l>erosion_circle(RegionFillUp, RegionErosion, 30)</l>
<l>gen_circle(Circle, Row, Column, tongPianRadRadius+27)</l>
<l>difference(SelectedRegions, Circle, RegionDifference)</l>
<l>opening_circle(RegionDifference, RegionOpening, 8)</l>
<l>connection(RegionOpening, ConnectedRegions2)</l>
<l>select_shape (ConnectedRegions2, ConnectedRegions2, 'area', 'and', 9000, 28000)</l>
<l>count_obj(ConnectedRegions2, Number)</l>
<l>circleTimes :=gouCount/2</l>
<l>if(Number!=gouCount)</l>
<l>    disp_message(hwnd, 'topfun5 提取钩部区域数量 ！='+gouCount, 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>    ret5 := -2</l>
<l>    if(Number%2=1)</l>
<l>        circleTimes := (Number+1)/2</l>
<l>    endif</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>GouRadiusRight:=[]</l>
<l>GouRadiusLeft:=[]</l>
<l>gen_empty_region(gouRadiusLineRight)</l>
<l>gen_empty_region(gouRadiusLineLeft)</l>
<c></c>
<l>select_obj(ConnectedRegions2, ObjectSelected1, 1)</l>
<l>shape_trans(ObjectSelected1, RegionTrans, 'outer_circle')</l>
<l>dilation_circle(RegionTrans, circleMudle, 50)</l>
<c></c>
<l>for Index := 1 to circleTimes by 1</l>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, -rad(360/22*(Index-1)), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(circleMudle, GouOuterCircle0, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    hom_mat2d_identity (HomMat2DIdentity)</l>
<l>    hom_mat2d_rotate (HomMat2DIdentity, rad(180), Row,Column,  HomMat2DRotate)</l>
<l>    affine_trans_region(GouOuterCircle0, GouOuterCircle1, HomMat2DRotate, 'constant')</l>
<c>    </c>
<l>    union2(GouOuterCircle0, GouOuterCircle1, GouOuterCircle)</l>
<l>    intersection(GouOuterCircle, ConnectedRegions2, TwoSymmetryGous)</l>
<l>    region_features(TwoSymmetryGous, 'area', TwoSymmetryGousArea)</l>
<l>    if(TwoSymmetryGousArea&lt;22000)</l>
<l>        disp_message(hwnd, 'topfun5 未找到对称区域', 'window', (Height1-400+300)/h, 20, 'red', 'true')</l>
<l>        ret5 := -3</l>
<l>        return()</l>
<l>    endif</l>
<l>    shape_trans(TwoSymmetryGous, TwoSymmetryGousConvex, 'convex')</l>
<l>    opening_circle(TwoSymmetryGousConvex, TwoSymmetryGousOpened, 30)</l>
<l>    region_features(TwoSymmetryGousOpened, 'max_diameter', twoOutGouDiameter)</l>
<c>    </c>
<c>    </c>
<c>    *半径线条及其长度</c>
<c>    *right-up</c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle0, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)</l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionRight)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineRight, RegionIntersectionRight, gouRadiusLineRight)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionRight, 'max_diameter', Value1)</l>
<l>    GouRadiusRight:=[GouRadiusRight,Value1]</l>
<c>    </c>
<c>    </c>
<c>    *left-down</c>
<l>    intersection(TwoSymmetryGous, GouOuterCircle1, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area1, Row1, Column1)</l>
<l>    aaa:=Row-Row1</l>
<l>    bbb:=Column-Column1</l>
<l>    tuple_sqrt ((aaa)*(aaa)+(bbb)*(bbb), cccc)</l>
<l>    sina:=(aaa)/cccc</l>
<l>    cosa:=(bbb)/cccc</l>
<l>    rowOffset:=1250*sina</l>
<l>    columnOffset:=1250*cosa</l>
<l>    rowDispPoint:=Row-rowOffset</l>
<l>    columnDispPoint:=Column-columnOffset</l>
<l>    gen_region_line(RegionLines, Row, Column, rowDispPoint, columnDispPoint)    </l>
<l>    intersection(RegionLines, TwoSymmetryGousOpened, RegionIntersectionLeft)</l>
<l>    if(Index == 1)</l>
<l>        union1(RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    else</l>
<l>        concat_obj(gouRadiusLineLeft, RegionIntersectionLeft, gouRadiusLineLeft)</l>
<l>    endif</l>
<l>    region_features(RegionIntersectionLeft, 'max_diameter', Value1)</l>
<l>    GouRadiusLeft:=[GouRadiusLeft,Value1]</l>
<l>endfor</l>
<c></c>
<l>tuple_concat(GouRadiusRight, GouRadiusLeft, GouRadiusAll2)</l>
<c></c>
<c></c>
<c></c>
<c>*计算两两之间的最大差值</c>
<l>subAbsMaxAll:=[]</l>
<c>*0-1</c>
<l>tuple_sub (GouRadiusAll0, GouRadiusAll1, sub0__1)</l>
<l>tuple_abs(sub0__1, subAbs0__1)</l>
<l>tuple_max(subAbs0__1, subAbsMax0__1)</l>
<l>subAbsMaxAll:=[subAbsMaxAll,subAbsMax0__1]</l>
<c>*0-2</c>
<l>tuple_sub (GouRadiusAll0, GouRadiusAll2, sub0__2)</l>
<l>tuple_abs(sub0__2, subAbs0__2)</l>
<l>tuple_max(subAbs0__2, subAbsMax0__2)</l>
<l>subAbsMaxAll:=[subAbsMaxAll,subAbsMax0__2]</l>
<c>*1-2</c>
<l>tuple_sub (GouRadiusAll1, GouRadiusAll2, sub1__2)</l>
<l>tuple_abs(sub1__2, subAbs1__2)</l>
<l>tuple_max(subAbs1__2, subAbsMax1__2)</l>
<l>subAbsMaxAll:=[subAbsMaxAll,subAbsMax1__2]</l>
<c></c>
<l>tuple_max(subAbsMaxAll, Max395)</l>
<l>tuple_min(subAbsMaxAll, Min396)</l>
<c></c>
<l>a400:=3</l>
<c>*是否显示震动检测的相关调试信息开关</c>
<l>if(1)</l>
<c>    *显示每张图的长度柱状图</c>
<c>    *5  10 与显示坐标系coordinateFun函数中的dev_set_part 参数有关</c>
<l>    coordinateRow:=2670/5</l>
<l>    coordinateColumn:=600/10</l>
<c>    </c>
<l>    GouRadiusAll0Show :=[GouRadiusAll0,1210]//保证每张max高度一致</l>
<l>    coordinateFun (hwnd, 'magenta', coordinateRow, coordinateColumn, GouRadiusAll0Show)</l>
<c>    </c>
<l>    GouRadiusAll1Show :=[GouRadiusAll1,1210]</l>
<l>    coordinateFun (hwnd, 'orange red', coordinateRow, coordinateColumn, GouRadiusAll1Show)</l>
<c>    </c>
<l>    GouRadiusAll2Show :=[GouRadiusAll2,1210]</l>
<l>    coordinateFun (hwnd, 'cyan', coordinateRow, coordinateColumn, GouRadiusAll2Show)</l>
<c>    </c>
<l>    msgColor0:='blue'</l>
<l>    msgColor01:='blue'</l>
<l>    msgColor02:='blue'</l>
<l>    msgColor12:='blue'</l>
<c>    *max value's color</c>
<l>    if(Max395==subAbsMax0__1)</l>
<l>        msgColor01:='magenta'</l>
<l>    elseif(Max395==subAbsMax0__2)</l>
<l>        msgColor02:='magenta'</l>
<l>    elseif(Max395==subAbsMax1__2)</l>
<l>        msgColor12:='magenta'</l>
<l>    endif</l>
<c>    *the color who will be used</c>
<l>    if(subAbsMax0__1&lt;a400)</l>
<l>        tuple_median(GouRadiusAll1, Median)</l>
<l>        disp_message(hwnd, '01-1RM:'+Median+'pix','window', (Height1-400+330-1400)/h, 105, 'cyan', 'false')</l>
<l>        msgColor01:='green'</l>
<l>    elseif(subAbsMax0__2&lt;a400)</l>
<l>        tuple_median(GouRadiusAll2, Median)</l>
<l>        disp_message(hwnd, '02-2RM:'+Median+'pix','window', (Height1-400+330-1400)/h, 105, 'cyan', 'false')</l>
<l>        msgColor02:='green'</l>
<l>    elseif(subAbsMax1__2&lt;a400)</l>
<l>        tuple_median(GouRadiusAll2, Median)</l>
<l>        disp_message(hwnd, '12-2RM:'+Median+'pix','window', (Height1-400+330-1400)/h, 105, 'cyan', 'false')</l>
<l>        msgColor12:='green'</l>
<l>    else</l>
<l>        disp_message(hwnd, 'NOSTD','window', (Height1-400+330-1400)/h, 110, 'cyan', 'false')</l>
<l>        msgColor0:='red'</l>
<l>        msgColor01:='red'</l>
<l>        msgColor02:='red'</l>
<l>        msgColor12:='red'</l>
<l>    endif</l>
<l>    disp_message(hwnd, 'topfun5 最大跳动:'+Max395 \
                       ,'window', (Height1-400+330)/h, 100, msgColor0, 'false')</l>
<l>    disp_message(hwnd, '| 0-1:'+subAbsMax0__1 \
                       ,'window', (Height1-400+330)/h, 260, msgColor01, 'false')</l>
<l>    disp_message(hwnd, '| 0-2:'+subAbsMax0__2 \
                       ,'window', (Height1-400+330)/h, 350, msgColor02, 'false')</l>
<l>    disp_message(hwnd, '| 1-2:'+subAbsMax1__2 \
                       ,'window', (Height1-400+330)/h, 440, msgColor12, 'false')</l>
<c></c>
<l>endif</l>
<c></c>
<c>*确定返回图片</c>
<l>if(subAbsMax0__1&lt;a400)</l>
<l>    *imageCorrectedSTD:=imageCorrected1</l>
<l>     ret5 := 10</l>
<l>elseif(subAbsMax0__2&lt;a400)</l>
<l>    *imageCorrectedSTD:=imageCorrected2</l>
<l>     ret5 := 20</l>
<l>elseif(subAbsMax1__2&lt;a400)</l>
<l>    *imageCorrectedSTD:=imageCorrected2</l>
<l>     ret5 := 21</l>
<l>else</l>
<l>    ret5 := -10</l>
<l>endif</l>
<c></c>
<c>*hv_hwnd</c>
<l>return ()</l>
<c></c>
<c></c>
<c></c>
</body>
<docu id="fun5">
<parameters>
<parameter id="gouchangMax"/>
<parameter id="gouchangMin"/>
<parameter id="hwnd"/>
<parameter id="imageCorrected0"/>
<parameter id="imageCorrected1"/>
<parameter id="imageCorrected2"/>
<parameter id="input_Scale_1"/>
<parameter id="ret5"/>
</parameters>
</docu>
</procedure>
<procedure name="coordinateFun">
<interface>
<ic>
<par name="hwnd" base_type="ctrl" dimension="0"/>
<par name="showColor" base_type="ctrl" dimension="0"/>
<par name="RowCoordinate" base_type="ctrl" dimension="0"/>
<par name="ColumnCoordinate" base_type="ctrl" dimension="0"/>
<par name="theTupleTobeShow" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c></c>
<l>get_part(hwnd, Row1, Column1, Row2, Column2)</l>
<c>*放大显示</c>
<l>dev_set_part(Row1, Column1, Row2/5, Column2/10)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<c></c>
<l>dev_set_color ('cyan')</l>
<l>disp_arrow(hwnd, RowCoordinate, ColumnCoordinate, RowCoordinate-300, ColumnCoordinate, 1)</l>
<l>disp_arrow(hwnd, RowCoordinate, ColumnCoordinate, RowCoordinate, ColumnCoordinate+300, 2)</l>
<c></c>
<c></c>
<l>disp_message(hwnd, '钩','image', RowCoordinate-260, ColumnCoordinate-8, 'cyan', 'false')</l>
<l>disp_message(hwnd, '半','image', RowCoordinate-240, ColumnCoordinate-8, 'cyan', 'false')</l>
<l>disp_message(hwnd, '经','image', RowCoordinate-220, ColumnCoordinate-8, 'cyan', 'false')</l>
<l>disp_message(hwnd, '3','image', RowCoordinate-200, ColumnCoordinate-8, 'cyan', 'false')</l>
<l>disp_message(hwnd, '张','image', RowCoordinate-180, ColumnCoordinate-8, 'cyan', 'false')</l>
<c></c>
<l>dev_set_draw ('margin')</l>
<l>dev_set_color (showColor)</l>
<c></c>
<c></c>
<l>tuple_sub(theTupleTobeShow, 1100, Diff)</l>
<c></c>
<l>gen_region_histo (HistoRegion1, Diff, (Height)/2, (Width)/2, 0.6)</l>
<l>region_features(HistoRegion1, ['row2','column1'], Value)</l>
<l>move_region(HistoRegion1, RegionMoved, RowCoordinate-Value[0], ColumnCoordinate-Value[1]+2)</l>
<c></c>
<l>dev_display(RegionMoved)</l>
<c></c>
<c>*复位</c>
<l>dev_set_part(Row1, Column1, Row2, Column2)</l>
<c>*hv_hwnd</c>
<l>return ()</l>
</body>
<docu id="coordinateFun">
<parameters>
<parameter id="ColumnCoordinate"/>
<parameter id="RowCoordinate"/>
<parameter id="hwnd"/>
<parameter id="showColor"/>
<parameter id="theTupleTobeShow"/>
</parameters>
</docu>
</procedure>
<procedure name="detectTop2">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="WindowHandle" base_type="ctrl" dimension="0"/>
<par name="prav2_1" base_type="ctrl" dimension="0"/>
<par name="prav2_2" base_type="ctrl" dimension="0"/>
<par name="prav2_3" base_type="ctrl" dimension="0"/>
<par name="prav2_4" base_type="ctrl" dimension="0"/>
<par name="prav2_5" base_type="ctrl" dimension="0"/>
<par name="prav2_6" base_type="ctrl" dimension="0"/>
<par name="prav2_7" base_type="ctrl" dimension="0"/>
<par name="prav2_8" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Result" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* </c>
<c>* 		output_Result 输出结果定义：</c>
<c>* 		static const int Good				= 0x00;</c>
<c>* 		static const int Bad					= 0x01;</c>
<c>* 		static const int Gou					= 0x02;</c>
<c>* 		static const int Cao					= 0x03;</c>
<c>* 		static const int Liantong			= 0x04;</c>
<c>* </c>
<l>dev_update_off ()</l>
<l>dev_set_draw ('margin')</l>
<l>dev_set_line_width (1)</l>
<l>set_display_font (WindowHandle, 11, 'mono', 'false', 'false')</l>
<c>* </c>
<l>* funReserve1 ()</l>
<l>copy_image (Image, imageCorrected)</l>
<l>copy_image (Image, imageCorrected1)</l>
<c></c>
<l>dev_display (imageCorrected)</l>
<c>* </c>
<l>disp_message (200000, 'argv:'+prav2_1+' '+prav2_2+' '+prav2_3+' '+prav2_4+' '+prav2_5+' '+prav2_6+' '+prav2_7+' '+prav2_8+' ', 'window', 0, 200, 'black', 'true')</l>
<c>* </c>
<l>disp_message (200000, '粘'+prav2_2+'宽'+prav2_2+'中'+prav2_2+'经'+prav2_2, 'window', 20, 0, 'black', 'true')</l>
<c>* </c>
<c>* </c>
<l>hwnd := 200000</l>
<l>ret1 := 0</l>
<l>ret2 := 0</l>
<l>ret3 := 0</l>
<l>ret4 := 0</l>
<c>* 检测顶面气孔（麻面）、缺料、J/H类型区别</c>
<l>top2fun1 (imageCorrected1, region1, prav2_5, prav2_6, hwnd, ret1)</l>
<c>* </c>
<c>* reserve</c>
<c>* top2fun2 (imageCorrected1, region2, hwnd, GouWidthDown, GouWidthUp, ret2)</c>
<c>* </c>
<c>* reserve</c>
<c>* top2fun3 (imageCorrected1, region3, hwnd, input_Scale_2, ret3)</c>
<c>*  </c>
<c>* reserve</c>
<c>* top2fun4 (imageCorrected1, region4, hwnd, input_Scale_1, (BaoLuoDiameterDown), (BaoLuoDiameterUp), ret4)</c>
<c>* </c>
<l>Result := 0</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<c>* </c>
<l>if (ret1&lt;0)</l>
<l>    disp_message (hwnd, 'NG 顶面破损/气孔', 'window', 50, 10, 'red', 'true')</l>
<l>    Result := 5</l>
<l>endif</l>
<c>* </c>
<c>* </c>
<l>if (ret1+ret2+ret3+ret4==0)</l>
<l>    set_display_font (WindowHandle, 20, 'mono', 'false', 'false')</l>
<l>    disp_message (hwnd, 'OK-良品', 'window', 40, 30, 'blue', 'true')</l>
<l>endif</l>
<l>set_display_font (WindowHandle, 11, 'mono', 'false', 'false')</l>
<l>stop ()</l>
<l>return ()</l>
<c></c>
</body>
<docu id="detectTop2">
<parameters>
<parameter id="Image"/>
<parameter id="Result"/>
<parameter id="WindowHandle"/>
<parameter id="prav2_1"/>
<parameter id="prav2_2"/>
<parameter id="prav2_3"/>
<parameter id="prav2_4"/>
<parameter id="prav2_5"/>
<parameter id="prav2_6"/>
<parameter id="prav2_7"/>
<parameter id="prav2_8"/>
</parameters>
</docu>
</procedure>
<procedure name="top2fun1">
<interface>
<io>
<par name="Image" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="region1" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="prav2_5" base_type="ctrl" dimension="0"/>
<par name="prav2_6" base_type="ctrl" dimension="0"/>
<par name="hwnd" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ret1" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c></c>
<c></c>
<l>ret1:=0</l>
<l>graythreshold:=80</l>
<l>areaoffset := 500000</l>
<l>tongPianRadRadius:=998//铜片构成的圆的大致半径</l>
<l>caoCount:=22//槽的数量</l>
<c></c>
<l>dev_set_color('green')</l>
<l>get_window_extents(hwnd, Row, Column, Width, Height)</l>
<l>get_image_size(Image, Width1, Height1)</l>
<l>tuple_real(Width, Width)</l>
<l>tuple_real(Height, Height)</l>
<l>w:=Width1/Width</l>
<l>h:=Height1/Height</l>
<c></c>
<l>gen_empty_region(EmptyRegion)</l>
<c></c>
<l>gen_ellipse (ROI_0, 1400, 2000, rad(-0.838415), 1640.18, 1524.72)</l>
<l>reduce_domain(Image, ROI_0, ImageReduced)</l>
<l>threshold (ImageReduced, Regions, 100, 255)</l>
<l>connection(Regions, ConnectedRegions)</l>
<l>select_shape (ConnectedRegions, SelectedRegions, ['circularity','area'], 'and', [0.85,276735], [1,492495])</l>
<l>count_obj(SelectedRegions, Number)</l>
<l>if(Number==0)</l>
<l>    disp_message(hwnd, 'top2fun1 选择中心圆eorror', 'window', (Height1-400)/h, 20, 'red', 'true')</l>
<l>    ret1 := -1</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>closing_circle(SelectedRegions, SelectedRegions_, 5)</l>
<l>opening_circle(SelectedRegions_, SelectedRegions, 10)</l>
<c></c>
<l>area_center(SelectedRegions, Area, Row1, Column1)</l>
<c>*J、H类型区别（通过内孔面积判断）J-381K/H-372K</c>
<c>*为prav2_6==0时，不做区别</c>
<l>if(prav2_6!=0)</l>
<l>    if(prav2_6==1)</l>
<l>        if(Area&lt;378000)</l>
<l>            disp_message(hwnd, 'top2fun1产品类型异常H', 'window', (Height1-400)/h, 20, 'red', 'true')</l>
<l>            ret1 := -5</l>
<l>            return()</l>
<l>        endif</l>
<l>    elseif(prav2_6==2)</l>
<l>        if(Area&gt;378000)</l>
<l>            disp_message(hwnd, 'top2fun1产品类型异常J', 'window', (Height1-400)/h, 20, 'red', 'true')</l>
<l>            ret1 := -5</l>
<l>            return()</l>
<l>        endif</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<l>gen_circle(circle1_, Row1, Column1, 350)</l>
<l>gen_circle(circle2_, Row1, Column1, 535)</l>
<l>gen_circle(circle3_, Row1, Column1, 620)</l>
<l>gen_circle(circle4_, Row1, Column1, 720)</l>
<l>gen_circle(circle5_, Row1, Column1, 780)</l>
<l>gen_circle(circle5__, Row1, Column1, 830)</l>
<l>gen_circle(circle6_, Row1, Column1, 890)</l>
<l>gen_circle(circle7_, Row1, Column1, 980)</l>
<c></c>
<l>gen_contour_region_xld(circle2_, Contours, 'border')</l>
<l>gen_region_contour_xld(Contours, circle2_M, 'margin')</l>
<l>gen_contour_region_xld(circle3_, Contours, 'border')</l>
<l>gen_region_contour_xld(Contours, circle3_M, 'margin')</l>
<l>gen_contour_region_xld(circle4_, Contours, 'border')</l>
<l>gen_region_contour_xld(Contours, circle4_M, 'margin')</l>
<c></c>
<l>R53:=15</l>
<l>dilation_circle(circle2_M, circle2_D, R53)</l>
<l>dilation_circle(circle3_M, circle3_D, R53)</l>
<l>dilation_circle(circle4_M, circle4_D, R53)</l>
<c></c>
<l>union2(circle2_D, circle3_D, circle23_D)</l>
<l>union2(circle23_D, circle4_D, circle234_D)</l>
<l>intensity(circle234_D, ImageReduced, Mean, Deviation)</l>
<l>dilation_circle(SelectedRegions, SelectedRegions_D, 10)</l>
<l>difference(circle5_, SelectedRegions_D, circleSel_5Dif)</l>
<l>reduce_domain(ImageReduced, circleSel_5Dif, ImageReduced1_)</l>
<l>threshold (ImageReduced1_, ImageReduced1_th, 50, 255)//</l>
<l>opening_circle(ImageReduced1_th, RegionWide, 8)</l>
<l>dilation_circle(RegionWide, RegionDilation, 10)</l>
<l>intersection(ImageReduced1_th, RegionDilation, RegionWideIntersection)</l>
<c></c>
<l>paint_region(circle234_D, ImageReduced1_, ImageResult, 6, 'fill')</l>
<l>intensity(circleSel_5Dif, ImageResult, Mean234, Deviation234)</l>
<c></c>
<l>threshold (ImageResult, ImageResult_th, 80, 255)//</l>
<l>union2(RegionWideIntersection, ImageResult_th, RegionUnion)</l>
<c></c>
<l>closing_circle(RegionUnion, RegionClosing, 10)</l>
<l>connection(RegionClosing, ConnectedRegions1)</l>
<l>select_shape (ConnectedRegions1, SelectedRegions1, 'area', 'and', 10, 500000)</l>
<l>union1(SelectedRegions1, RegionUnion1)</l>
<c></c>
<l>debugMark:=0</l>
<c></c>
<c>*052J产品内圈2/1有亮块，判为良品</c>
<l>gen_circle(circle2__, Row1, Column1, 430)</l>
<l>intersection(circle2__, RegionUnion1, RegionIntersection)</l>
<l>opening_circle(RegionIntersection, RegionOpening__, 17)//</l>
<l>dilation_circle(RegionOpening__, RegionDilation2, 35)</l>
<l>intersection(RegionIntersection, RegionDilation2, RegionIntersection1)</l>
<c></c>
<l>difference(RegionUnion1, circle2__, RegionDifference)</l>
<l>union2(RegionDifference, RegionIntersection1, RegionUnion2)</l>
<c></c>
<c>*中、内环缺料检测</c>
<l>connection(RegionUnion2, ConnectedRegions2)</l>
<l>select_shape_std(ConnectedRegions2, SelectedRegions2Max, 'max_area', 70)</l>
<l>count_obj(SelectedRegions2Max, Number1)</l>
<l>if(Number1&gt;0)</l>
<l>    region_features(SelectedRegions2Max, ['area','inner_radius'], MaxInfoValues)</l>
<l>    if(MaxInfoValues[0]&gt;2000 and MaxInfoValues[1]&gt;18)</l>
<l>        if(debugMark==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, RegionUnion1, EmptyRegion)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>*气孔检测</c>
<l>union1(EmptyRegion, region1)</l>
<l>region_features(region1, 'area', errorRgnArea)</l>
<l>if(errorRgnArea==0 and ret1==0)</l>
<l>    region_features(RegionUnion2, 'area', Value)</l>
<l>    if(Value&gt;prav2_5)</l>
<l>        if(debugMark==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, RegionUnion1, EmptyRegion)</l>
<l>    else</l>
<l>        dev_display(SelectedRegions1)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>*最外环缺料检测，窄亮斑去除,留下宽亮斑区域</c>
<l>difference(circle6_, circle5_, Difference65)</l>
<l>reduce_domain(Image, Difference65, ImageReduced65)</l>
<l>threshold (ImageReduced65, Regions65, 70, 255)//</l>
<l>connection(Regions65, ConnectedRegions65)</l>
<l>fill_up(ConnectedRegions65, RegionFillUp65)</l>
<l>select_shape_std(RegionFillUp65, SelectedRegions65max, 'max_area', 70)</l>
<l>count_obj(SelectedRegions65max, NumberMax65)</l>
<l>if(NumberMax65&gt;0)</l>
<l>    region_features(SelectedRegions65max, ['area','inner_radius'], MaxInfo65Values)</l>
<l>    if(MaxInfo65Values[0]&gt;1700 and MaxInfo65Values[1]&gt;12)</l>
<l>        if(debugMark==1)</l>
<l>            stop()</l>
<l>        endif</l>
<l>        concat_obj(EmptyRegion, SelectedRegions65max, EmptyRegion)</l>
<l>    endif</l>
<l>endif</l>
<c></c>
<c>*槽区环缺料，通槽</c>
<l>difference(circle7_, circle6_, Difference76)</l>
<l>reduce_domain(Image, Difference76, ImageReduced76)</l>
<l>threshold (ImageReduced76, Regions76, 240, 255)</l>
<l>connection(Regions76, ConnectedRegions76)</l>
<l>select_shape (ConnectedRegions76, SelectedRegions76, 'inner_radius', 'and', 12, 50)</l>
<l>count_obj(SelectedRegions76, Number76)</l>
<l>if(Number76&gt;0)</l>
<l>    if(debugMark==1)</l>
<l>        stop()</l>
<l>    endif</l>
<l>    concat_obj(EmptyRegion, SelectedRegions76, EmptyRegion)</l>
<l>endif</l>
<c></c>
<c>*缺料or轻度擦伤情况下，灰度值差异不是很明显情况检测</c>
<c>*3/4环之间为凸起平面，容易因为接触而导致沾灰or粗糙，也会有轻度灰度差异，造成大量误判</c>
<c>*每一环斜度、高度、粗糙度都不完全相同，在检测轻微擦伤时不能联合检测</c>
<l>* difference(circle5_, circle2_, RegionDifference52_)</l>
<l>* difference(RegionDifference52_, circle234_D, circle234_D_52)</l>
<l>* reduce_domain(ImageResult, circle234_D_52, ImageReduced234_D_52)</l>
<l>* intensity(circle234_D_52, ImageReduced234_D_52, Mean234_D_52, Deviation234_D_52)</l>
<l>* threshold (ImageReduced234_D_52, Regions234_D_52, Mean234_D_52+10, 255)</l>
<l>* closing_circle(Regions234_D_52, RegionClosing234_D_52, 3.5)</l>
<l>* fill_up(RegionClosing234_D_52, RegionFillUp234_D_52)</l>
<l>* opening_circle(RegionFillUp234_D_52, RegionOpening234_D_52, 10)</l>
<l>* connection(RegionOpening234_D_52, ConnectedRegions234_D_52)</l>
<l>* select_shape (ConnectedRegions234_D_52, SelectedRegions234_D_52, 'area', 'and', 15000, 500000)</l>
<l>* count_obj(SelectedRegions234_D_52, Number234_D_52)</l>
<l>* if(Number234_D_52&gt;0)</l>
<l>*     concat_obj(EmptyRegion, SelectedRegions234_D_52, EmptyRegion)</l>
<l>* endif</l>
<c>*所以先只对5/4环斜坡面做相应检测</c>
<l>difference(circle5__, circle4_, RegionDifference54)</l>
<l>erosion_circle(RegionDifference54, RegionErosion54, 20)</l>
<l>reduce_domain(Image, RegionErosion54, ImageReduced54)</l>
<l>intensity(RegionDifference54, ImageReduced54, Mean54, Deviation54)</l>
<l>threshold (ImageReduced54, Regions54, Mean54+20, 255)//</l>
<l>opening_circle(Regions54, RegionOpening54, 2)</l>
<l>closing_circle(RegionOpening54, RegionClosing54, 10)//</l>
<l>fill_up(RegionClosing54, RegionFillUp54)</l>
<l>opening_circle(RegionFillUp54, RegionOpening54, 10)</l>
<l>connection(RegionOpening54, ConnectedRegions54)</l>
<l>select_shape (ConnectedRegions54, SelectedRegions54, 'inner_radius', 'and', 18, 500)</l>
<l>count_obj(SelectedRegions54, Number54)</l>
<l>if(Number54&gt;0)</l>
<l>    if(debugMark==1)</l>
<l>        stop()</l>
<l>    endif</l>
<l>    concat_obj(EmptyRegion, SelectedRegions54, EmptyRegion)</l>
<l>endif</l>
<c>*对4/3环（接触摩擦环，易沾异物，粗糙）进行检测</c>
<l>difference(circle4_, circle3_, RegionDifference43)</l>
<l>reduce_domain(Image, RegionDifference43, ImageReduced43)</l>
<l>intensity(RegionDifference43, ImageReduced43, Mean43, Deviation43)</l>
<l>threshold (ImageReduced43, Region43, Mean43+30, 255)//</l>
<l>opening_circle(Region43, RegionOpening43, 2)</l>
<l>closing_circle(RegionOpening43, RegionClosing43, 10)//</l>
<l>fill_up(RegionClosing43, RegionFillUp43)</l>
<l>opening_circle(RegionFillUp43, RegionOpening43, 10)</l>
<l>connection(RegionOpening43, ConnectedRegions43)</l>
<l>select_shape (ConnectedRegions43, SelectedRegions43, 'inner_radius', 'and', 20, 500)</l>
<l>count_obj(SelectedRegions43, Number43)</l>
<l>if(Number43&gt;0)</l>
<l>    if(debugMark==1)</l>
<l>        stop()</l>
<l>    endif</l>
<l>    concat_obj(EmptyRegion, SelectedRegions43, EmptyRegion)</l>
<l>endif</l>
<c></c>
<c></c>
<l>union1(EmptyRegion, region1)</l>
<l>region_features(region1, 'area', errorRgnArea)</l>
<l>if(errorRgnArea&gt;0 and ret1==0)</l>
<l>    ret1 := -10</l>
<l>endif</l>
<c></c>
<l>dev_set_color('red')</l>
<l>*dev_set_line_width(2)</l>
<l>dilation_circle(region1, RegionDilation1, 30)</l>
<l>dev_display(RegionDilation1)</l>
<l>*dev_set_line_width(1)</l>
<c>*hv_hwnd</c>
<c></c>
<c></c>
<l>return ()</l>
</body>
<docu id="top2fun1">
<parameters>
<parameter id="Image"/>
<parameter id="hwnd"/>
<parameter id="prav2_5"/>
<parameter id="prav2_6"/>
<parameter id="region1"/>
<parameter id="ret1"/>
</parameters>
</docu>
</procedure>
<procedure name="funReserve1">
<interface/>
<body>
<c></c>
</body>
<docu id="funReserve1">
<parameters/>
</docu>
</procedure>
</hdevelop>
